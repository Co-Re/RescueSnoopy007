---
title: "Algorithmik & Statistik Lab 2: Finaler Bericht - 'Rescue Snoopy'"
author: "Lara Knapwost - 1810837601, Cornelia Reithmeier - 1810837362, Isabelle Veitl - 1810837521, Anna Weber - 1810837818"
date: '15. Juni 2019'
output: 
  html_document:
    toc: TRUE
urlcolor: cyan
---
***
Unter dem Arbeitstitel "Rescue Snoopy" wurden in einem ersten Schritt die unten beschriebenen Daten ausgewählt, analysiert und das statistische Analyse-Interesse dargelegt.
Die gemeinsame Arbeit an diesem Projekt wird über Github abgewickelt und dokumentiert: https://github.com/Co-Re/RescueSnoopy007
 

# Ausgewähltes Datenset
Für die Gruppenarbeit werden Daten von Kaggle verwendet:  
https://www.kaggle.com/aaronschlegel/austin-animal-center-shelter-intakes-and-outcomes#aac_intakes.csv

Von den dort gesammelten Daten wird folgende Datei verwendet: `aac_intakes_outcomes`

Das Datenset enthält unter anderem folgende Variablen:

* `animal_id` - eindeutige ID des Tieres
* `age_upon_outcome` - Alter des Tieres bei Outcome
* `date_of_birth` - Geburtsdatum des Tieres (geschätzt, wenn dieses nicht bekannt war)
* `outcome_subtype` - spezifische Beschreibung des Outcomes
* `outcome_type` - Art des Outcomes
* `datetime` - Datum und Uhrzeit des Outcomes
* `outcome_number` - Anzahl, wie oft ein Tier das Tierheim schon verlassen hat
* `sex_upon_outcome` - Geschlecht des Tieres und ob das Tier kastriert wurde
* `age_upon_intake` - Alter des Tieres bei Aufnahme in String-Format 
* `animal_type` - Tierart
* `breed` - Tierrasse
* `color` - Tierfarbe
* `datetime` - Datum und Uhrzeit der Aufnahme
* `found_location` - Adresse oder Bereich, wo das Tier gefunden wurde 
* `intake_condition` - Zustand des Tieres bei der Aufnahme
* `intake_type` - kategorisierter Aufnahmetyp
* `name` - Name des Tieres
* `sex_upon_intake` - Geschlecht des Tieres und ob das Tier kastriert wurde
* `intake_number` - Anzahl, wie oft ein Tier schon zum Tierheim gebracht wurde
* `time_in_shelter` - Zeit im Tierheim

Neben diesen Variablen existierten weitere, die beispielsweise Zeiträume in einem anderen Format darstellen.

## Hintergrundinformationen zum Datenset
Die Daten wurden vom [Austin Animal Center](http://www.austintexas.gov/department/aac) erhoben. Dieses Animal Center ist das größte Tierheim in den USA, in dem keine Tiere getötet werden und kann bis zu 18.000 Tiere pro Jahr aufnehmen. Es werden alle Arten von Tieren aufgenommen. Das Tierheim befindet sich im Travis County im US-Bundesstaat Texas.
Die Daten werden im Rahmen der Austin Open Data Intitiative online bereitgestellt.  

Das Datenset enthält n = 79.672 Observationen und 41 Variablen.   
Die Daten stammen aus der Zeit zwischen Oktober 2013 bis April 2018 (Outcomes).  
Die Tiere sind zwischen 0-25 Jahre alt, der Median liegt bei 1 Jahr, die Geschlechtsverteilung männlicher und weiblicher Tiere liegt fast bei 50/50.  
Mehr als die Hälfte der Tiere sind Hunde, gefolgt von Katzen und einigen Vögeln (<500). Etwa 4.500 Tiere sind keiner Spezies zugeordnet.   
Knapp die Hälfte der im Datenset enthaltenen Tiere wurde adoptiert.   

## Statistische Lernaufgabe
Im Rahmen der Gruppenarbeit soll folgendes Klassifikationsproblem betrachtet werden:

Vorhersage des Outcome-Types auf Basis der gegebenen Variablen. Die initale Idee war es, die Prädiktoren zu finden, anhand derer eine Rückgabe an den Besitzer, ein Transfer / eine Adoption, Euthanasie, Tod etc. möglichst genau (durch Vorhersage der Klasse) vorhergesagt werden können. Im Zuge des Preprocessings und nach detaillierten Auseinandersetzungen stellte sich heraus, dass für viele der angeführten Outcome-Typen wenige Fälle vorhanden sind, sodass eine Modellierung ohne Overfitting schwierig erscheint. Deshalb wurde während des Projektes bzw. zu Ende des Preprocessings der Datensatz auf Tierarten mit mindestens n=500 eingeschränkt und ausschließlich der Outcome-Type Adoption verwendet. 

## Motivation
Es gibt viele Tierheime und durch Hörensagen ist bekannt, dass in vielen davon eine Großzahl der Tiere einen beträchtlichen Teil ihres Lebens verbringen. 
Es ist interessant für uns, herauszufinden, welche Aspekte ausschlaggebend dafür sind, ob das Tier (vor dem Tod) wieder aus dem Tierheim "entlassen" wird, d.h. einen neuen Besitzer findet. Wir haben einige Hypothesen, welche wir prüfen möchten. Wir gehen davon aus, dass vor allem jüngere, gesunde Tiere eine bessere Chance haben, als ältere, kranke, ggf. auch nicht kastrierte (Streuner-)Tiere, die bereits sehr lange im Tierheim sind.   
Weiß man, welche Aspekte eine Rolle spielen, könnte man diese gezielt in den Tierheimen in der Kommunikation verwenden, um mehr Tieren (z.B. vor allem jenen, die grundsätzlich eine schlechtere Chance für eine Adoption haben) ein neues zu Hause zu geben.   
Wir haben uns für dieses Datenset mit dieser Fragestellung entschieden, da einige von uns selbst Haustiere besitzen und wir den Eindruck haben, dass es bereits ausreichend viele Analysen zu ökonomischen Fragestellungen gibt.

***

# Initiales Preprocessing


```{r load packages, include=F, message=FALSE, warning = FALSE}
pacman::p_load(
plyr, 
anytime,
lubridate,
kableExtra, 
caret,
rpart.plot,
dummies,
dplyr,
neuralnet,
tibble,
vip,
labeling,
e1071)
```

## Laden der Daten
```{r load data, results='hide'}
aac_intakes_outcomes = read.csv("aac_intakes_outcomes.csv")
```

## Überprüfung der Datenstruktur
<details>
  <summary>Code Details</summary>
```{r check structure}
str(aac_intakes_outcomes)
# Andrucken der ersten Datensätze
head(aac_intakes_outcomes)
```
</details>
<details>
  <summary>Code Details</summary>
```{r summary1}
summary(aac_intakes_outcomes)
```
</details>

### Datenbereinigung I - Konvertieren der Datentypen
```{r datatypes}
aac_intakes_outcomes$animal_id_outcome <- as.character(aac_intakes_outcomes$animal_id_outcome)
aac_intakes_outcomes$date_of_birth <- anytime(aac_intakes_outcomes$date_of_birth)

aac_intakes_outcomes$sex_upon_outcome[is.na(aac_intakes_outcomes$sex_upon_outcome)] <- "Unknown"
aac_intakes_outcomes$sex_upon_outcome[is.element(aac_intakes_outcomes$sex_upon_outcome, "NULL")] <- "Unknown"
aac_intakes_outcomes$sex_upon_outcome_first <- as.factor(sapply(strsplit(as.character(aac_intakes_outcomes$sex_upon_outcome), " "), "[", 1))
aac_intakes_outcomes$sex_upon_outcome_second <- sapply(strsplit(as.character(aac_intakes_outcomes$sex_upon_outcome), " "), "[", 2)
aac_intakes_outcomes$sex_upon_outcome_second[is.na(aac_intakes_outcomes$sex_upon_outcome_second)] <- "Unknown"
aac_intakes_outcomes$sex_upon_outcome_second <- as.factor(aac_intakes_outcomes$sex_upon_outcome_second)

aac_intakes_outcomes$age_upon_outcome_.days. <- as.numeric(aac_intakes_outcomes$age_upon_outcome_.days.)
aac_intakes_outcomes$outcome_datetime <- anytime(aac_intakes_outcomes$outcome_datetime)
aac_intakes_outcomes$outcome_month <- as.factor(aac_intakes_outcomes$outcome_month)
aac_intakes_outcomes$outcome_year <- as.factor(aac_intakes_outcomes$outcome_year)
aac_intakes_outcomes$outcome_hour <- as.factor(hour(aac_intakes_outcomes$outcome_datetime))
aac_intakes_outcomes$dob_month <- as.factor(aac_intakes_outcomes$dob_month)
aac_intakes_outcomes$dob_year <- as.factor(aac_intakes_outcomes$dob_year)
aac_intakes_outcomes$animal_id_intake <- as.character(aac_intakes_outcomes$animal_id_intake)

aac_intakes_outcomes$sex_upon_intake[is.na(aac_intakes_outcomes$sex_upon_intake)] <- "Unknown"
aac_intakes_outcomes$sex_upon_intake_first <- as.factor(sapply(strsplit(as.character(aac_intakes_outcomes$sex_upon_intake), " "), "[", 1))
aac_intakes_outcomes$sex_upon_intake_second <- sapply(strsplit(as.character(aac_intakes_outcomes$sex_upon_intake), " "), "[", 2)
aac_intakes_outcomes$sex_upon_intake_second[is.na(aac_intakes_outcomes$sex_upon_intake_second)] <- "Unknown"
aac_intakes_outcomes$sex_upon_intake_first[is.na(aac_intakes_outcomes$sex_upon_intake_first)] <- "Unknown"
aac_intakes_outcomes$sex_upon_intake_second <- as.factor(aac_intakes_outcomes$sex_upon_intake_second)

aac_intakes_outcomes$count <- as.numeric(aac_intakes_outcomes$count)
aac_intakes_outcomes$age_upon_intake_.days. <- as.numeric(aac_intakes_outcomes$age_upon_intake_.days.)
aac_intakes_outcomes$intake_datetime <- anytime(aac_intakes_outcomes$intake_datetime)
aac_intakes_outcomes$intake_month <- as.factor(aac_intakes_outcomes$intake_month)
aac_intakes_outcomes$intake_year <- as.factor(aac_intakes_outcomes$intake_year)
aac_intakes_outcomes$intake_hour <- as.factor(hour(aac_intakes_outcomes$intake_datetime))
```

### Anmerkungen für weitere Preprocessing Schritte

Folgende Animal-Types sind vorhanden:
```{r table animals, echo=FALSE}
table(aac_intakes_outcomes$animal_type)
```

Unter Other verbergen sich großteils unterschiedliche Nage- und Säugetiere bzw. Kleintiere, die in einem folgenden Datenaufbereitungsschritt feingliedriger aufgedrosselt werden.

Folgende Kombinationen sind bei der Zeugungsfähigkeit des Geschlechts möglich, wobei in den Zeilen der Zustand bei Aufnahme im Tierheim dargestellt wird, in den Spalten der Zustand beim Verlassen:

```{r crosstable1, echo=FALSE}
table(aac_intakes_outcomes$sex_upon_intake_first, aac_intakes_outcomes$sex_upon_outcome_first) 

```
Unplausible Fälle (kastrierter Income, nichtkastrierter Outcome) werden im Zuge der Datenaufbereitung zu Unknown rekategorisiert.


### Erstellung eines neuen Datasets und Entfernung von Variablen
Das neue Dataset enthält nicht alle Variablen. 

<details>
  <summary>Code Details</summary>
```{r create new dataframe}
aac_intakes_outcomes2 <- aac_intakes_outcomes[c(5, 22:24, 26, 27, 43, 42, 44, 3, 17, 18, 33:35, 39, 10:12, 30, 7, 40, 41)]
```
</details>

Im Folgenden findet sich eine Auflistung der entfernten Variablen, sowie eine Begründung, weshalb einige Daten nicht für die Analyse miteinbezogen werden. 
Folgende Variablen wurden für das neue Dataset nicht verwendet:

* `found_location` - Diese Variable bietet keine gute Datenqualität, es sind nicht immer gleiche Daten erfasst (z.B. manchmal Ortsname, manchmal komplette Adresse). Eine Bereinigung bzw. Kürzung auf den Ortsnamen bringt keinen Erkenntnisgewinn für das Modell, da alle Aufnahmen in derselben Region stattfanden und einzig über die Adressangabe Subregionen miteinander vergleichbar wären. 
* `sex_open_intake` - Diese Variable enthält die selben Daten wie `sex_open_outcome`, ist daher redundant.

```{r crosstable2, echo=FALSE}
table(aac_intakes_outcomes$sex_upon_intake_second, aac_intakes_outcomes$sex_upon_outcome_second)
```

* `outcome_subtype` - Diese Variable enthält nur für sehr wenige Datensätze zusätzliche Informationen, diese sind nicht durchgängig je `Outcome_type` befüllt. Außerdem ist die Kategorisierung nicht gänzlich diskriminant, da z.B. Aggressive eine Teilkategorie von Behavior wäre, wobei nicht klar ist, welches Verhaltensmuster dann in Behavior erfasst wurde bzw. ob dieses mit aggressivem Verhalten gleichzusetzen ist. 

```{r crosstable3, echo=FALSE}
table(aac_intakes_outcomes$outcome_subtype, aac_intakes_outcomes$outcome_type)
```

* `animal_id_outcome` - ID kann nicht für Klassifikation verwendet werden.
* `sex_upon_outcome` - Diese Variable wurde gesplittet, die neuen Variablen werden verwendet
* `outcome_monthyear` - Der Monat und das Jahr werden als einzelne Variablen verwendet. Diese Ursprungsvariable wird damit nicht mehr benötigt.
* `outcome_hour` - Es werden auch zu ungewöhnlichen Uhrzeiten (z.B. Mitternacht) Geschäftsfälle registriert, welche nicht plausibel erscheinen. 

```{r crosstable4, echo=FALSE}
table(aac_intakes_outcomes$outcome_hour)
```

* `dob_monthyear` - Geburtsdatum. Der Monat und das Jahr werden als einzelne Variablen verwendet. Diese Ursprungsvariable wird damit nicht mehr benötigt.
* `animal_id_intake` - ID kann nicht für Klassifikation verwendet werden
* `sex_upon_intake` - Diese Variable wurde gesplittet, die neuen Variablen werden verwendet
* `count` - alle Werte sind 1 (Aushilfsspalte) d.h. kein Informationsgewinn durch diese Variable

```{r table1, echo=FALSE}
table(aac_intakes_outcomes$count)
```

* `intake_monthyear` - der Monat und das Jahr werden als einzelne Variablen verwendet
* `intake_hour` - Es werden auch zu ungewöhnlichen Uhrzeiten Geschäftsfälle registriert, welche unplausibel erscheinen.

```{r table2, echo=FALSE}
table(aac_intakes_outcomes$intake_hour)
```

* `outcome_weekday`, `intake_weekday` - es soll keine Klassifikation auf Basis eines Wochentages gemacht werden.
* `outcome_number` - Diese Variable enthält dieselben Informationen wie `intake_number`, ist daher redundant.

```{r table3, echo=FALSE}
table(aac_intakes_outcomes$outcome_number, aac_intakes_outcomes$intake_number)
```

* `age_upon_intake`, `age_upon_intake_year` - Diese Variablen enthalten dieselben Informationen wie age_upon_intake_days.
* `age_upon_intake_group` - Die Gruppierung liefert keinen Mehrwert, da darin nicht die extrem variierende Lebenserwartung in Abhängigkeit der Tierart berücksichtigt wird.
* `age_upon_outcome`, `age_upon_outcome_year` - Diese Variablen enthalten dieselben Informationen wie `age_upon_outcome_days`.
* `age_upon_outcome_group` - Die Gruppierung liefert keinen Mehrwert, da darin nicht die extrem variierende Lebenserwartung in Abhängigkeit der Tierart berücksichtigt wird.


# Preprocessing II

## Prüfung auf fehlende Werte

Über die Summary wird geprüft, wo fehlende Werte vorkommen.
```{r summary2, results='hide'}
summary(aac_intakes_outcomes2)
```

Für die Prüfung werden zuerst alle Ausprägungen der Response `outcome_type` angesehen und bereinigt. 
```{r check uniques}
unique(aac_intakes_outcomes2$outcome_type)
table(aac_intakes_outcomes2$outcome_type)
```

```{r clean outcometype,  results='hide'}
v = as.vector(which(aac_intakes_outcomes2$outcome_type == ""))
aac_intakes_outcomes2 <- aac_intakes_outcomes2[-v,]
aac_intakes_outcomes2$outcome_type <- factor(aac_intakes_outcomes2$outcome_type)
```


## Anpassen des Animal Types Other

Auf Basis der Breed Variable wird die fehlende Information der Tierrasse (Ausprägung Other) aufgefüllt. 

<details>
  <summary>Code Details</summary>
```{r}
others = aac_intakes_outcomes2[aac_intakes_outcomes2$animal_type  == "Other", ] 
```
</details>

```{r count others, echo=FALSE, fig.cap = "Anzahl der Tiere, deren Animaltype Information fehlt"}
count(others)
```

<details>
  <summary>Code Details</summary>
```{r recode animal_type}

# Erstellen eines csv files um die verschiedenen Rassen Tieren zuordnen zu können 
# write.csv(count(others$breed), file = "breed.csv", append = FALSE, quote = TRUE, sep = " ",
#             eol = "\n", na = "NA", dec = ".", row.names = TRUE,
#             col.names = TRUE, qmethod = c("escape", "double"),
#             fileEncoding = "")

# Entfernen von "Mix"
new_animal_type <- gsub(" Mix","",others$breed)

#Ersetzen aller Rassen die Rabbit enthalten
new_animal_type <-
gsub("(.*)?Rabbit(.*)?", "Rabbit", new_animal_type)

# Ersetzen aller Rassen die Rabbit Rassen sind
rabbit_pattern <-
"(American Sable|Angora|Belgian Hare|Britannia Petit|Californian|Checkered Giant|Cinnamon|Cottontail|Dutch|English Spot|Flemish Giant|Harlequin|Havana|Himalayan|Hotot|Jersey Wooly|Lionhead|Lop|Netherlnd Dwarf|New Zealand Wht|Rex|Ringtail|Silver|Polish)"
rabbit_pattern <- paste("(.*)?", rabbit_pattern, "(.*)?", sep = "")
new_animal_type <- gsub(rabbit_pattern, "Rabbit", new_animal_type)

# Gerbil mit Mouse ersetzen
new_animal_type <- gsub("(.*)?Gerbil(.*)?", "Mouse", new_animal_type)

# Chinchilla
new_animal_type <- gsub("(.*)?Chinchilla(.*)?", "Chinchilla", new_animal_type)

# Snake
new_animal_type <- gsub("(.*)?Snake(.*)?", "Snake", new_animal_type)

# Pig
new_animal_type <- gsub("(.*)?Pig(.*)?", "Pig", new_animal_type)

# Fish
new_animal_type <- gsub("(.*)?Cold Water(.*)?", "Fish", new_animal_type)

# Ersetzen von Rassen, die nicht bekannt sind, mit "Other"
new_animal_type <- gsub("(.*)?(American|Tropical)(.*)?", "Other", new_animal_type)

others$animal_type = new_animal_type

# Ersetzen der Animaltypen für Other in der Original Tabelle

tmp_aac<- aac_intakes_outcomes2

tmp_aac$animal_type = as.character(tmp_aac$animal_type)

typeof(others$animal_type)
typeof(tmp_aac$animal_type)
tmp_aac[tmp_aac$animal_type  == "Other", ] = others

aac_intakes_outcomes2 = tmp_aac

aac_intakes_outcomes2$animal_type <- as.factor(aac_intakes_outcomes2$animal_type)

```
</details>

Nach Bereinigung der Variable liegt folgende Verteilung vor:
```{r after cleaning animaltype, echo=FALSE}
table(aac_intakes_outcomes2$animal_type)
```



## Anpassen der Animal Color

Um die Anzahl der Ausprägungen, welche im Originaldatenset hoch ist (knapp 100 verschiedene Farben), zu reduzieren, werden ähnliche Farben agreggiert. 
```{r table4, results='hide' }
sort(table(aac_intakes_outcomes2$color),decreasing=T)
```

<details>
  <summary>Code Details</summary>
```{r clean color}
#Zusammenfassen der Farben 
aac_intakes_outcomes2$color_new <-
gsub("Brown/Brown|Sable|Chocolate|Agouti|Liver", "Brown", aac_intakes_outcomes2$color)
aac_intakes_outcomes2$color_new <- gsub("(Black/Black)", "Black",aac_intakes_outcomes2$color_new)
aac_intakes_outcomes2$color_new <- gsub("(White/White)", "White",aac_intakes_outcomes2$color_new)
aac_intakes_outcomes2$color_new <- gsub("(Gold/Gold)", "Gold",aac_intakes_outcomes2$color_new)
aac_intakes_outcomes2$color_new <- gsub("(Yellow/Yellow)", "Yellow",aac_intakes_outcomes2$color_new)
aac_intakes_outcomes2$color_new <- gsub("(Cream|Tan|Gold|Lynx|Buff|Fawn)", "Beige",aac_intakes_outcomes2$color_new)
  
#Zusammenfassen von Multicolor-Farben
aac_intakes_outcomes2$color_new <-
gsub("(.*)?/(.*)?", "Multicolor", aac_intakes_outcomes2$color_new)
aac_intakes_outcomes2$color_new <- gsub("(Tricolor|Tortie|Calico|Torbie|Seal)", "Multicolor",aac_intakes_outcomes2$color_new)

#Entfernen von  non-color Information
aac_intakes_outcomes2$color_new <- gsub(" Tabby| Point| Merle| Smoke| Tick| Brindle| Tiger", "", aac_intakes_outcomes2$color_new)
aac_intakes_outcomes2$color_new <-
gsub("(.*)? (.*)", "Multicolor", aac_intakes_outcomes2$color_new)

aac_intakes_outcomes2$color_new <-
gsub("Flame", "Orange", aac_intakes_outcomes2$color_new)

aac_intakes_outcomes2$color_new <- as.factor(aac_intakes_outcomes2$color_new)
aac_intakes_outcomes2 <- aac_intakes_outcomes2[,-4]

```
</details>

Nach Bereinigung der Variable konnte die Anzahl an Farben extrem reduziert werden:
```{r table5, echo= FALSE}
table(aac_intakes_outcomes2$color_new)
```

## Neuberechnung der Altersangaben und Tage im Tierheim 

Da die bestehenden Alters-/Zeitangaben teilweise nicht mit den Datumsangaben übereingestimmt haben, werden diese neu berechnet bzw. überprüft.
Beim Alter bei Intake bzw. Outcome kommen dabei auch negative Werte vor. Zum Teil kann darauf geschlossen werden, dass das trächtige Muttertier vor der Geburt eingeliefert wurde und somit das Alter des Nachwuchs beim Intake im Minusbereich lag. In diesen Fällen wird es auf 0 gesetzt. Andere unschlüssige Fälle werden exkludiert.

<details>
  <summary>Code Details</summary>
```{r calculate age}
# Age upon intake
dtime <- round(difftime(aac_intakes_outcomes2$intake_datetime, aac_intakes_outcomes2$date_of_birth,
         units = c("days")))
aac_intakes_outcomes2$age_upon_intake_days_calc <- dtime

# Age upon outcome
dtime2 <- round(difftime(aac_intakes_outcomes2$outcome_datetime, aac_intakes_outcomes2$date_of_birth,
         units = c("days")))
aac_intakes_outcomes2$age_upon_outcome_days_calc <- dtime2

# Time in shelter
dtime3 <- round(difftime(aac_intakes_outcomes2$outcome_datetime, aac_intakes_outcomes2$intake_datetime,
         units = c("days")), digits = 5)
aac_intakes_outcomes2$time_in_shelter_days_calc <- dtime3

# Alle überflüssigen Features entfernen, die nun nicht mehr benötigt werden
aac_intakes_outcomes2[ ,c('age_upon_intake_.days.', 'age_upon_outcome_.days.', 'time_in_shelter_days', 'date_of_birth', 'intake_datetime', 'outcome_datetime')] <- list(NULL)

# Spalten umbennen
names(aac_intakes_outcomes2)[names(aac_intakes_outcomes2) == "age_upon_outcome_days_calc"] <- "age_upon_outcome_.days."
names(aac_intakes_outcomes2)[names(aac_intakes_outcomes2) == "age_upon_intake_days_calc"] <- "age_upon_intake_.days."
names(aac_intakes_outcomes2)[names(aac_intakes_outcomes2) == "time_in_shelter_days_calc"] <- "time_in_shelter_days"

# Negatives Alter exkludieren bzw. auf Null setzen
aac_intakes_outcomes_temp1 <- 
  aac_intakes_outcomes2[aac_intakes_outcomes2$age_upon_intake_.days.  >= -46 &
                        aac_intakes_outcomes2$age_upon_outcome_.days.  >= 0, ]
aac_intakes_outcomes2 <- aac_intakes_outcomes_temp1

aac_intakes_outcomes2$age_upon_intake_.days.[aac_intakes_outcomes2$age_upon_intake_.days.< 0] <- 0


#Löschen der alten Variable time_in_shelter

aac_intakes_outcomes2$time_in_shelter <- NULL

```
</details>

<details>
  <summary>Code Details</summary>
```{r check recodings2}
# Kontrolle, dass Alter bei Outcome immer höher ist als bei Intake
aac_intakes_outcomes_temp2 <- 
  aac_intakes_outcomes2[aac_intakes_outcomes2$age_upon_intake_.days. >
                        aac_intakes_outcomes2$age_upon_outcome_.days., ]
```
</details>

## Anpassen der Zeugungsfähigkeit

Bei Analyse der Daten wurde bemerkt, dass 3 Beobachtungen bei den Geschlechtsmerkmalen fehlerhaft sein müssen, da Intake und Outcome-Wert nicht zusammengepasst haben (siehe oben bei Anmerkungen zu Datenset). Bei diesen Beobachtungen war das Merkmal bei Intake Neutered/Spayed und bei Outcome Intact. Es wurde daher entschieden, dass diese Datensätze behalten werden und die Werte durch "Unknown" ersetzt werden.   
Da Neutered und Spayed unterschiedliche Wordings für die Sterilisation der weiblichen bzw. männlichen Tiere sind, wurden diese vereinheitlicht in der Ausprägung "Sterilized" zusammengefasst.

<details>
  <summary>Code Details</summary>
```{r recode sterilized}
detectwrong <- function(v1,c1,v2,c2,x) {ifelse((v1==c1)&(v2==c2),"Unknown",x)}

aac_intakes_outcomes2$sex_upon_intake_first_new <- detectwrong(
  aac_intakes_outcomes2$sex_upon_intake_first,
  "Neutered",
  aac_intakes_outcomes2$sex_upon_outcome_first,
  "Intact",
  detectwrong(
    aac_intakes_outcomes2$sex_upon_intake_first,
    "Spayed", 
    aac_intakes_outcomes2$sex_upon_outcome_first, 
    "Intact", 
    as.character(aac_intakes_outcomes2$sex_upon_intake_first)
    )
  )

aac_intakes_outcomes2$sex_upon_outcome_first_new <- detectwrong(
  aac_intakes_outcomes2$sex_upon_intake_first,
  "Neutered", 
  aac_intakes_outcomes2$sex_upon_outcome_first,
  "Intact", 
  detectwrong(
    aac_intakes_outcomes2$sex_upon_intake_first,
    "Spayed", 
    aac_intakes_outcomes2$sex_upon_outcome_first, 
    "Intact", 
    as.character(aac_intakes_outcomes2$sex_upon_outcome_first)
    )
  )

# Zusammenfassung in "Sterilized"
aac_intakes_outcomes2$sex_upon_intake_first_new[aac_intakes_outcomes2$sex_upon_intake_first_new == "Neutered"] <- "Sterilized"
aac_intakes_outcomes2$sex_upon_intake_first_new[aac_intakes_outcomes2$sex_upon_intake_first_new == "Spayed"] <- "Sterilized"
aac_intakes_outcomes2$sex_upon_outcome_first_new[aac_intakes_outcomes2$sex_upon_outcome_first_new == "Neutered"] <- "Sterilized"
aac_intakes_outcomes2$sex_upon_outcome_first_new[aac_intakes_outcomes2$sex_upon_outcome_first_new == "Spayed"] <- "Sterilized"

# Kontrolle der Änderungen
table(aac_intakes_outcomes2$sex_upon_intake_first_new,aac_intakes_outcomes2$sex_upon_outcome_first_new)

# Als Faktor formatieren, Entfernen der alten Spalten und Umbenennen
aac_intakes_outcomes2$sex_upon_intake_first_new <- as.factor(aac_intakes_outcomes2$sex_upon_intake_first_new)
aac_intakes_outcomes2$sex_upon_outcome_first_new <- as.factor(aac_intakes_outcomes2$sex_upon_outcome_first_new)

aac_intakes_outcomes2$sex_upon_intake_first <- NULL
aac_intakes_outcomes2$sex_upon_outcome_first <- NULL

names(aac_intakes_outcomes2)[names(aac_intakes_outcomes2) == "sex_upon_intake_first_new"] <- "sex_upon_intake_first"
names(aac_intakes_outcomes2)[names(aac_intakes_outcomes2) == "sex_upon_outcome_first_new"] <- "sex_upon_outcome_first"
```
</details>


## Einschränkung der Tierarten 

```{r, echo=FALSE}
summary(aac_intakes_outcomes2$animal_type)

```
Da eine statistische Modellierung für Tierarten mit geringer Anzahl an Fällen nicht sinnvoll erscheint, wurde an dieser Stelle eine weitere Einschränkung des Datensatzes entschieden.

Der primäre Fokus der Vorhersage des Outcometypes soll nun bei Hunden und Katzen liegen. 
Jedoch sollen auch Tiere, von denen mind. n=500 Beobachtungen vorliegen, betrachtet werden, und zwar: 

* Dog: 45.364
* Cat: 29.536
* Bat:  2.205
* Raccoon: 706
* Rabbit: 513

Für jede Tierart soll ein eigenes Modell gefittet werden, gegebenenfalls müssen dann in weiterer Folge aufgrund zu geringer Fallzahlen die Tierarten weiter eingeschränkt werden. 

```{r remove animaltypes with too few cases, echo=FALSE}
aac_intakes_outcomes3<- data.frame(subset(aac_intakes_outcomes2, animal_type=="Dog"|animal_type=="Cat"|animal_type=="Bat"|animal_type=="Raccoon"|animal_type=="Rabbit"))


aac_intakes_outcomes2 <- aac_intakes_outcomes3
aac_intakes_outcomes2$animal_type <- factor(aac_intakes_outcomes2$animal_type)
summary(aac_intakes_outcomes2$animal_type)

```

### Verteilung der Y-Variable für verbleibende Tierarten
```{r plot1, echo=FALSE}
a<- ggplot(aac_intakes_outcomes2, aes(animal_type))+geom_bar(fill = "#0073C2FF") 

a+geom_bar(aes(fill = outcome_type))

```

<details>
  <summary>Code Details</summary>
```{r check numerics}
types <- table(aac_intakes_outcomes2$animal_type, aac_intakes_outcomes2$outcome_type)
types[order(types[,1], decreasing=T),]
```
</details>

## Einschränkung des OutcomeTypes

Da das Interesse des Tierheims vorallem darin liegt, dass Hunde, Katzen und Hasen *adoptiert* werden, und dieser Anteil auch bei den beiden Tierarten relativ hoch ist, d.h. ausreichend Daten zum trainieren des Modells vorhanden sind, soll für diese Tierarten dieser *Outcometype* vorhergesagt werden. 

### weitere Einschränkung nach Outcome Type und Tierart

Da der Anteil bei Wildtieren, die eingeschläfert werden, sehr hoch ist, liegen nur wenige Fälle für andere Outcome types vor, weshalb an dieser Stelle davon abgesehen wird, Modelle für Racoons und Bats aufzustellen.  

Im Folgenden wird deshalb der Datensatz weiter reduziert (durch Entfernung der Wildtiere), es sollen ausschließlich Hunde, Katzen und Hasen verbleiben. Es wird eine neue Variable erstellt, die binär codiert angibt, ob das jeweilige Tier adoptiert wurde. 

<details>
  <summary>Code Details</summary>
```{r remove wild animals and dummycode adoption, warning=FALSE, message=FALSE}
#entferne wildtiere

aac_intakes_outcomes_3 <- subset(aac_intakes_outcomes2, animal_type  == "Dog" | animal_type == "Cat" | aac_intakes_outcomes2$animal_type  == "Rabbit")
aac_intakes_outcomes_3$animal_type <- factor(aac_intakes_outcomes_3$animal_type)

#dummycodierung für Adoption

dummies_outcometype <- data.frame(aac_intakes_outcomes_3$outcome_type)
dummies_outcometype <- dummy.data.frame(dummies_outcometype)

aac_intakes_outcomes_3$outcome_type_adopt <- dummies_outcometype[,1]

```
</details>

<details>
  <summary>Code Details</summary>
```{r check recoding2 and merge datasets, message=FALSE, warning=FALSE}
aac_intakes_outcomes_3$outcome_type <- factor(aac_intakes_outcomes_3$outcome_type)
table(aac_intakes_outcomes_3$outcome_type, aac_intakes_outcomes_3$outcome_type_adopt)

aac_intakes_outcomes2 <- aac_intakes_outcomes_3
```
</details>

### Adoptionen nach Tieren

Es liegen ausreichend Daten für die Vorhersage der Adoption vor. 

```{r}
b<- ggplot(aac_intakes_outcomes2, aes(animal_type))+geom_bar(fill = "#0073C2FF") 

b+geom_bar(aes(fill = outcome_type_adopt))

```
```{r table6, include=FALSE}
t<-table(aac_intakes_outcomes2$outcome_type_adopt, aac_intakes_outcomes2$animal_type)
t

#Relative Anteile der Outcometypes
table<- prop.table(t,2)

<details>
  <summary>Code Details</summary>
```{r table6}
table(aac_intakes_outcomes2$animal_type, aac_intakes_outcomes2$outcome_type_adopt)
```
</details>

Da ein erster Testlauf/Fitting des Datensatzes mit einem Decision Tree aufgrund der Datenstrukturen wenig performant ist, wurden die Daten überwiegend Dummycodiert um ein schnelleres Training zu erzielen. 

<details>
  <summary>Code Details</summary>
```{r recode dummies, warning=FALSE, message=FALSE}
#Löschung unbenötigter Spalten: outcometype (alle types) &date_of_birth_month & year

aac_intakes_outcomes2 <- aac_intakes_outcomes2[,c(2:6,9:20)]

#Dummycodierungen

dummies_intake_condition <- dummy.data.frame(data.frame(aac_intakes_outcomes2$intake_condition))
aac_intakes_outcomes2$intake_conditionAged <- dummies_intake_condition[,1]
aac_intakes_outcomes2$intake_conditionFeral <- dummies_intake_condition[,2]
aac_intakes_outcomes2$intake_conditionInjured <- dummies_intake_condition[,3]
aac_intakes_outcomes2$intake_conditionNormal <- dummies_intake_condition[,4]
aac_intakes_outcomes2$intake_conditionNursing <- dummies_intake_condition[,5]
aac_intakes_outcomes2$intake_conditionOther <- dummies_intake_condition[,6]
aac_intakes_outcomes2$intake_conditionPregnant <- dummies_intake_condition[,7]
aac_intakes_outcomes2$intake_conditionSick <- dummies_intake_condition[,8]

dummies_intake_type <- dummy.data.frame(data.frame(aac_intakes_outcomes2$intake_type))
aac_intakes_outcomes2$intake_typeEuthanasiaRequest <- dummies_intake_type[,1]
aac_intakes_outcomes2$intake_typeOwnerSurrender <- dummies_intake_type[,2]
aac_intakes_outcomes2$intake_typePublicAssist <- dummies_intake_type[,3]
aac_intakes_outcomes2$intake_typeStray <- dummies_intake_type[,4]
aac_intakes_outcomes2$intake_typeWildlife <- dummies_intake_type[,5]

dummies_suos <- dummy.data.frame(data.frame(aac_intakes_outcomes2$sex_upon_outcome_second))
aac_intakes_outcomes2$sexuponoutcomesecond_female <- dummies_suos[,1]
aac_intakes_outcomes2$sexuponoutcomesecond_male <- dummies_suos[,2]
aac_intakes_outcomes2$sexuponoutcomesecond_unknown <- dummies_suos[,3]

dummies_intake_month <- dummy.data.frame(data.frame(aac_intakes_outcomes2$intake_month))
aac_intakes_outcomes2$intake_month1 <- dummies_intake_month[,1]
aac_intakes_outcomes2$intake_month2 <- dummies_intake_month[,2]
aac_intakes_outcomes2$intake_month3 <- dummies_intake_month[,3]
aac_intakes_outcomes2$intake_month4 <- dummies_intake_month[,4]
aac_intakes_outcomes2$intake_month5 <- dummies_intake_month[,5]
aac_intakes_outcomes2$intake_month6 <- dummies_intake_month[,6]
aac_intakes_outcomes2$intake_month7 <- dummies_intake_month[,7]
aac_intakes_outcomes2$intake_month8 <- dummies_intake_month[,8]
aac_intakes_outcomes2$intake_month9 <- dummies_intake_month[,9]
aac_intakes_outcomes2$intake_month10 <- dummies_intake_month[,10]
aac_intakes_outcomes2$intake_month11 <- dummies_intake_month[,11]
aac_intakes_outcomes2$intake_month12 <- dummies_intake_month[,12]

dummies_intake_year <- dummy.data.frame(data.frame(aac_intakes_outcomes2$intake_year))
aac_intakes_outcomes2$intake_year2013 <- dummies_intake_year[,1]
aac_intakes_outcomes2$intake_year2014 <- dummies_intake_year[,2]
aac_intakes_outcomes2$intake_year2015 <- dummies_intake_year[,3]
aac_intakes_outcomes2$intake_year2016 <- dummies_intake_year[,4]
aac_intakes_outcomes2$intake_year2017 <- dummies_intake_year[,5]
aac_intakes_outcomes2$intake_year2018 <- dummies_intake_year[,6]

dummies_outcome_month <- dummy.data.frame(data.frame(aac_intakes_outcomes2$outcome_month))
aac_intakes_outcomes2$outcome_month1 <- dummies_outcome_month[,1]
aac_intakes_outcomes2$outcome_month2 <- dummies_outcome_month[,2]
aac_intakes_outcomes2$outcome_month3 <- dummies_outcome_month[,3]
aac_intakes_outcomes2$outcome_month4 <- dummies_outcome_month[,4]
aac_intakes_outcomes2$outcome_month5 <- dummies_outcome_month[,5]
aac_intakes_outcomes2$outcome_month6 <- dummies_outcome_month[,6]
aac_intakes_outcomes2$outcome_month7 <- dummies_outcome_month[,7]
aac_intakes_outcomes2$outcome_month8 <- dummies_outcome_month[,8]
aac_intakes_outcomes2$outcome_month9 <- dummies_outcome_month[,9]
aac_intakes_outcomes2$outcome_month10 <- dummies_outcome_month[,10]
aac_intakes_outcomes2$outcome_month11 <- dummies_outcome_month[,11]
aac_intakes_outcomes2$outcome_month12 <- dummies_outcome_month[,12]

dummies_outcome_year <- dummy.data.frame(data.frame(aac_intakes_outcomes2$outcome_year))
aac_intakes_outcomes2$outcome_year2013 <- dummies_outcome_year[,1]
aac_intakes_outcomes2$outcome_year2014 <- dummies_outcome_year[,2]
aac_intakes_outcomes2$outcome_year2015 <- dummies_outcome_year[,3]
aac_intakes_outcomes2$outcome_year2016 <- dummies_outcome_year[,4]
aac_intakes_outcomes2$outcome_year2017 <- dummies_outcome_year[,5]
aac_intakes_outcomes2$outcome_year2018 <- dummies_outcome_year[,6]

dummies_color <- dummy.data.frame(data.frame(aac_intakes_outcomes2$color_new))

#prüfe ob plausible Farben für übrige Tierrassen.  table(aac_intakes_outcomes2$color_new, aac_intakes_outcomes2$animal_type)
#Grün keine Werte mehr. Andere Farben alle plausibel

aac_intakes_outcomes2$colorApricot <- dummies_color[,1]
aac_intakes_outcomes2$colorBeige <- dummies_color[,2]
aac_intakes_outcomes2$colorBlack <- dummies_color[,3]
aac_intakes_outcomes2$colorBlue <- dummies_color[,4]
aac_intakes_outcomes2$colorBrown <- dummies_color[,5]
aac_intakes_outcomes2$colorGray <- dummies_color[,6]
aac_intakes_outcomes2$colorLilac <- dummies_color[,7]
aac_intakes_outcomes2$colorMulticolor <- dummies_color[,8]
aac_intakes_outcomes2$colorOrange <- dummies_color[,9]
aac_intakes_outcomes2$colorPink <- dummies_color[,10]
aac_intakes_outcomes2$colorRed <- dummies_color[,11]
aac_intakes_outcomes2$colorSilver <- dummies_color[,12]
aac_intakes_outcomes2$colorWhite <- dummies_color[,13]
aac_intakes_outcomes2$colorYellow <- dummies_color[,14]

aac_intakes_outcomes2$age_upon_intake_.days. <- as.numeric(aac_intakes_outcomes2$age_upon_intake_.days.)
aac_intakes_outcomes2$age_upon_outcome_.days. <- as.numeric(aac_intakes_outcomes2$age_upon_outcome_.days.)
aac_intakes_outcomes2$time_in_shelter_days <- as.numeric(aac_intakes_outcomes2$time_in_shelter_days)

dummies_suif<- dummy.data.frame(data.frame(aac_intakes_outcomes2$sex_upon_intake_first))
aac_intakes_outcomes2$sex_upon_intake_first_Intact <- dummies_suif[,1]
aac_intakes_outcomes2$sex_upon_intake_first_Sterilized <- dummies_suif[,2]
aac_intakes_outcomes2$sex_upon_intake_first_Unknown <- dummies_suif[,3]

dummies_suof<- dummy.data.frame(data.frame(aac_intakes_outcomes2$sex_upon_outcome_first))
aac_intakes_outcomes2$sex_upon_outcome_first_Intact <- dummies_suof[,1]
aac_intakes_outcomes2$sex_upon_outcome_first_Sterilized <- dummies_suof[,2]
aac_intakes_outcomes2$sex_upon_outcome_first_Unknown <- dummies_suof[,3]

aac_intakes_outcomes2$outcome_type_adopt <- as.factor(aac_intakes_outcomes2$outcome_type_adopt)
aac_intakes_outcomes2$breed <- as.factor(aac_intakes_outcomes2$breed)

#Entfernen aller 10 Originalspalten, die Dummycodiert wurden

aac_intakes_outcomes2[ ,c('intake_condition', 'intake_type', 'sex_upon_outcome_second', 'intake_month', 'intake_year', 'outcome_month', 'outcome_year', 'color_new', 'sex_upon_intake_first', 'sex_upon_outcome_first')] <- list(NULL)


```
</details>

# Finale Datensätze zur Modellierung

```{r datasets new, message=FALSE, warning=FALSE}
allanimals <- aac_intakes_outcomes2
dummies_animals<- dummy.data.frame(data.frame(allanimals$animal_type))

allanimals$cat <- dummies_animals[,1]
allanimals$dog <- dummies_animals[,2]
allanimals$rabbit <- dummies_animals[,3]

allanimals<- allanimals[,-c(1)]

```


## Split Daten nach Tier 

Das finale Datenset dient für das Subsetting pro Tierart. 
Da für jede Tierart ein eigenes Modell gefittet wird, wird die Tierartvariable innerhalb dieser Datensätze nicht benötigt und entfernt.

```{r dataset split, results='hide'}

rabbits <- subset(aac_intakes_outcomes2, animal_type == "Rabbit")
rabbits <- rabbits[,-c(1)]

dogs <- subset(aac_intakes_outcomes2, animal_type == "Dog")
dogs <- dogs[,-c(1)]

cats <- subset(aac_intakes_outcomes2, animal_type == "Cat")
cats <- cats[,-c(1)]

```

### Train Test Split - alle Tierarten
<details>
  <summary>Code Details</summary>
```{r}

train_function <- createDataPartition(
  y = allanimals$outcome_type_adopt,
  p = .70,
  list = FALSE
)

training <- allanimals[ train_function,]
testing  <- allanimals[-train_function,]
```
</details>

### Train/Test Split für Hunde

Jedes Subset wird wiederum in ein Test- und Trainingsset unterteilt. 
Beispiel Hunde:
```{r, results='hide'}
train_function <- createDataPartition(
  y = dogs$outcome_type_adopt,
  p = .70,
  list = FALSE
)

training_dog <- dogs[train_function,]
testing_dog  <- dogs[-train_function,]
```

### Train/Test Split für Katzen
<details>
  <summary>Code Details</summary>
```{r}
train_function <- createDataPartition(
  y = cats$outcome_type_adopt,
  p = .70,
  list = FALSE
)

training_cat <- cats[ train_function,]
testing_cat  <- cats[-train_function,]
```
</details>

### Train/Test Split für Hasen
<details>
  <summary>Code Details</summary>
```{r}
train_function <- createDataPartition(
  y = rabbits$outcome_type_adopt,
  p = .70,
  list = FALSE
)

training_rabbit <- rabbits[ train_function,]
testing_rabbit  <- rabbits[-train_function,]
```
</details>

***

# Aufstellen der Modelle
Zuerst werden Modell mithilfe von Decisoin Trees aufgestellt, da diese gut interpretierbar sind. Danach wird untersucht, ob andere Methoden wie neuronale Netze ein ähnliches oder sogar besseres Ergebnis hinsichtlich Accuracy liefern.

## Decision Trees

Allgemeine Werte
```{r define CV and seed, results='hide'}
cv_5 = trainControl(method = "cv", number = 5)
seed_val = 123
```


Laden der gespeicherten Decision Tree Modelle
```{r load RData, results='hide'}
if (file.exists("decision_trees.RData"))
  load("decision_trees.RData")
```


### Decision Tree für Hunde

Wie auch bei der Datensatzerstellung je Tierart werden im Folgenden pro Tierart Klassifikationsbäume mit 5-fold crossvalidation gefittet. Dafür werden alle Variablen im Datensatz und die Methode 'rpart' aus dem Caret Package verwendet, um eine Adoption vorherzusagen. 
```{r tree dogs, results='hide'}
set.seed(seed_val)

if (!exists("tree_dog1"))
  tree_dog1 <- train(
    outcome_type_adopt ~ .,
    data = training_dog,
    trControl = cv_5,
    method = "rpart")
```

Das gefittete Modell: 

```{r print tree dogs, echo=FALSE}
print(tree_dog1)
```

```{r confusion matrix dogs, echo=FALSE}
pred_tree_dog1 <- predict(tree_dog1, testing_dog)
conf_matrix_tree_dog1 <- confusionMatrix(pred_tree_dog1, testing_dog$outcome_type)
conf_matrix_tree_dog1
```

```{r model plot, echo=FALSE}
rpart.plot(tree_dog1$finalModel)
```

*Interpretation*
Der Tree zeigt, dass zuerst time_in_shelter eine Rolle spielt und somit die erste Abzweigung im Baum ist. Als weitere Variable verwendet der Baum sex_upon_outcome_first_ Sterilized = 0.
Wenn der Hund weniger als 4 Tage im Tierheim ist, scheint eine Adoption auf Basis des Modells also als unwahrscheinlich (vermutlich handelt es sich dabei um entlaufene Tiere die bereits innerhalb der ersten 4 Tage wieder vom Besitzer abgeholt werden), wohingegen bei Hunden, die länger als 4 Tage im Tierheim verbleiben, die Wahrscheinlichkeit einer Adoption dann hoch ist, wenn der Hund sterilisiert ist. 

Die Specificity ist mit 87% um fast 20% höher als die Sensitivity, d.h. die Vorhersage von Hunden, die *nicht* adoptiert werden, ist genauer, als die für Hunde, die adoptiert werden. Gleichzeitig muss festgehalten werden, dass das Modell nur eine Accuracy von 76% hat, weshalb eine weitere Optimierung besonders sinnvoll erscheint. 

### Decision Tree für Katzen
<details>
  <summary>Code Details</summary>
```{r cats tree1}
set.seed(seed_val)
if (!exists("tree_cat1"))
  tree_cat1 <- train(
    outcome_type_adopt ~ .,
    data = training_cat,
    trControl = cv_5,
    method = "rpart")
```
</details>

Das gefittete Modell: 

```{r cats tree2,  echo=FALSE}
print(tree_cat1)
```

```{r confusion matrix cats,  echo=FALSE}
pred_tree_cat1 <- predict(tree_cat1, testing_cat)
conf_matrix_tree_cat1 <- confusionMatrix(pred_tree_cat1, testing_cat$outcome_type)
conf_matrix_tree_cat1
```

```{r plot model cats, echo=FALSE}
rpart.plot(tree_cat1$finalModel)
```

*Interpretation*

Bei Katzen ist sex_upon_outcome_first_Sterilized = 0 die erste Split Variable des Baumes, gefolgt von dem Alter und der Zeit, die die Katze im Tierheim verbracht hat.
Daher scheinen für die Adoption einer Katze ähnliche Kriterien eine Rolle zu spielen, wie bei Hunden. Im Gegensatz zur Wahrscheinlichkeit einer Adoption eines Hundes spielt diesem Klassifikationsbaum zufolge auch das Alter der Katze eine Rolle: Wenn die Katze sterilisiert, und älter als ein halbes Jahr alt ist, ist eine Adoption wahrscheinlich. Ist die Katze jünger als ein halbes Jahr, hängt die Adoption davon ab, wie lange die Katze bereits im Tierheim war (Wahrscheinlich ist eine Adoption nämlich nur dann, wenn sie bereits länger als 12 Tage dort war).
Dies könnte daran liegen, dass Jungtiere erst ab einem bestimmten Alter adoptiert (und sterilisiert) werden können. 

Im Vergleich zum ersten Tree für die Vorhersage einer Adoption eines Hundes, zeigt sich beim Entscheidungsbaum für Katzen ohne Optimierung bereits eine bessere bzw. höhere Accuracy von über 80%. Auffallend ist im direkten Vergleich der Modelle vor allem auch, dass bei Katzen (umgekehrt als bei Hunden), die Adoption besser vorhergesagt werden kann (Sensitivity = 88%), als Fälle, in denen Katzen nicht adoptiert werden (Specificity = 81,5%). 

### Decision Tree für Hasen
<details>
  <summary>Code Details</summary>
```{r model fitting rabbits}
set.seed(seed_val)

if (!exists("tree_rabbit1"))
  tree_rabbit1 <- train(
    outcome_type_adopt ~ .,
    data = training_rabbit,
    trControl = cv_5,
    method = "rpart")
```
</details>

Das gefittete Modell: 

```{r print model, echo=FALSE}
print(tree_rabbit1)
```

```{r confusion matrix rabbits, echo=FALSE}
pred_tree_rabbit1 <- predict(tree_rabbit1, testing_rabbit)
conf_matrix_tree_rabbit1 <- confusionMatrix(pred_tree_rabbit1, testing_rabbit$outcome_type)
conf_matrix_tree_rabbit1
```

```{r model plot2, echo=FALSE}
rpart.plot(tree_rabbit1$finalModel)
```

*Interpretation*

Bei Hasen ist der einzige Splitpunkt sex_upon_outcome_first_Sterilized = 0. Daher erfolgt die Vorhersage einer Adoption eines Hasens ausschließlich auf Basis der Information, ob das Tier sterilisiert ist. Wie auch bei den anderen Tieren ist die Adoptionswahrscheinlichkeit dann deutlich höher, wenn das Tier bereits sterilisiert ist.
Die Accuracy ist mit 88% noch besser als jene der anderen beiden Trees (Hunde und Katzen). 

<details>
  <summary>Code Details</summary>
```{r save decision trees}
if (!file.exists("decision_trees.RData"))
  save(tree_dog1, tree_cat1, tree_rabbit1, file = "decision_trees.RData")

```
</details>

## Variable Importance

Je Modell ist eine Tabelle der Wichtigkeit einer Variable sowie eine Grafik dargestellt. Die Tabelle enthält lediglich Variablen, bei denen die Importance größer 0 ist.

### Variable Importance des Hundemodells

```{r}
imp_dog = vi(tree_dog1)
imp_dog = imp_dog[imp_dog$Importance>0,]
imp_dog_tab = tibble(Variable = imp_dog$Variable, Importance = imp_dog$Importance)
imp_dog_tab
vip(tree_dog1, width = 0.5, fill = "green3")
```

Die einfachen Klassifikationsbäume geben bereits einen guten ersten Einblick darin, welche Variablen für die Klassifikation bzw Splitpunkte vorrangig herangezogen werden. 
Da sich zeigt, dass über die Tierarten hinweg die Hauptsplitpunkte auf ähnlichen Variablen basieren, soll mithilfe der Variable Importance ermittelt werden, ob noch weitere Zusatzinformationen aus den Modellen gewonnen werden können, die für das Tierheim für das bessere Verständnis von Adoptionsgründen genutzt werden kann. 
Dafür wird die Variable Importance aus den obig erstellten Bäumen (je Tier) erstellt und beschrieben. 

Es ist ersichtlich, dass für den Decision Tree der Hunde 6 Prädiktoren eine Rolle spielen:
* `sex_upon_outcome_first_Sterilized`
* `sex_upon_outcome_first_Intact`
* `time_in_shelter_days`
* `intake_typePublic Assist`
* `age_upon_intake_.days.`
* `intake_typeStray`

Die wichtigsten Variablen sind neben der bereits im Decisiontree als Splitpunkt ermittelten `sex_upon_outcome_first_Sterilized` auch das `sex_upon_outcome_first_Intact.`

### Variable Importance des Katzenmodells

```{r}
imp_cat = vi(tree_cat1)
imp_cat = imp_cat[imp_cat$Importance>0,]
imp_cat_tab = tibble(Variable = imp_cat$Variable, Importance = imp_cat$Importance)
imp_cat_tab
vip(tree_cat1, width = 0.5, fill = "green3")
```

Im Modell der Katzen finden sich ähnliche Prädiktoren wieder, hinzugekommen ist hier:
* `age_upon_outcome_.days.`
* `sex_upon_intake_first_Sterilized`
* `sex_upon_intake_first_Intact`
* `sexuponoutcomesecond_unknown`
* `intake_typeStray`

Hier ist im Gegensatz zu den Hunden das Alter der Tiere und die `time_in_shelter` am wichtigsten.

### Variable Importance des Hasenmodells
```{r}
imp_rab= vi(tree_rabbit1)
imp_rab = imp_rab[imp_rab$Importance>0,]
imp_rab_tab = tibble(Variable = imp_rab$Variable, Importance = imp_rab$Importance)
imp_rab_tab
vip(tree_rabbit1, width = 0.5, fill = "green3")
```

Hier ist wie im Modell der Hunde die Variable `sex_upon_outcome_first_Sterilized` am wichtigsten.
Neben den bekannten Prädiktoren sind u.a. noch die Prädiktoren
* `intake_year2016`
* `outcome_year2016`
* `intake_year2015`
* `outcome_month9`
* `outcome_year2014`
von Bedeutung.

Die Relevanz der Jahreszeiten lässt darauf schließen, dass die Adoptionen von Hasen sich über die Jahre hinweg unterscheiden. Was Grund für das Ausreißerjahr 2016 war, müsste anhand von Brancheninformationen ermittelt werden, es könnt z.B. sein, dass es vermehrte mediale Aufmerksamkeit (z.B. durch Kampagnen / Testimonials) oder eine Art "Haustiertrend-Boost" für Hasen in diesem Jahr gab. 



## Tree Tuning (Bagging, Boosting, Random Forest)
Es wurde versucht, noch weitere Trees, getunt mit Bagging, Boosting bzw Random Forest, aufzustellen. Aufgrund der Datenmenge und Rechenkapaziätsgrenzen konnten diese nicht ausgeführt werden und es ist hier nur ein Beispielcode bzw. ein gespeichertes Beispielmodel angeführt. In einem weiteren Schritt werden daher weitere Modelle mit Neuronalen Netzen auf.
### Auswahl Daten 
```{r eval=FALSE}


data_train_model <- training_cat[,-c(1:5)]
data_test_model <- testing_cat[,-c(1)]
```

### Random Forrest mit OOB 
Max. Zahl für das tuneGrid (für die Metry) wurde mit 9 gewählt, da üblicherweise das Optimum von m= Wurzel aus p, d.h. Wurzel aus 78=9 (gerundet)
```{r eval=FALSE}
trcOOB <- trainControl(method="oob")

randomforest_OOB <- train(
  outcome_type_adopt ~ .,
  data = data_train_model,
  method = "rf",
  tuneGrid = expand.grid(mtry=seq(1,10,1)),
  trControl = trcOOB
)
```

### Modell für Katzen
Der Random Forest mit OOB konnte beispielhaft für ein reduziertes Subsample mit 1000 Cat-Datensätzen gespeichert werden.
```{r eval=FALSE}
load("randomforestOOB_cats_n=1000.Rdata")
```

```{r eval=FALSE}
RF_OOB_predict = predict(randomforest_OOB, data_test_model)
conf_matrix_RF_OOB <- confusionMatrix(RF_OOB_predict, data_test_model$outcome_type)
```

## Neuronales Netzwerk

Die Bäume dienen als gut interpretierbare Modelle für ein besseres Verständnis der Adoptionsgründe, nun soll noch getestet werden, ob ein Modell, dass primär auf Vorhersage, als auf Interpretierbarket abzielt, helfen kann, die Modellaccuracy noch weiter zu steigern. 
Bei den neuronalen Netzen wird die Breed Variable ausgeschlossen, da sie  bei den Bäumen als nicht relevant identifiziert wurde. Außerdem werden die numerischen Variablen intake_number, age_upon_intake_.days, age_upon_outcome_.days und time_in_shelter_days vorab min-max normalisiert, um die Geschwindigkeit der Berechnung zu erhöhen (für das Hundedatenset konnte ohne Normalisierung aus Computer Performance technischen Gründen gar keine Berechnung  durchgeführt werden). Die Normalisierung ermöglichte dann eine (schnellere) Berechnung.
Es werden für jede Tierart jeweils zwei neuronale Netze erstellt, einmal mit allen Variablen und einmal mit den Variablen, die im Decision Tree schon als wichtig festgestellt wurden. 

Es wird erwartet, dass das Modell, das alle Variablen inkludiert, eine höhere Accuracy erzielt als jenes, das nur eine Teilmenge der Variablen enthält (weil die Mustererkennung unter Berücksichtigung von mehr Variablen genauer sein müsste). Andererseits soll auch getestet werden, ob ausschließlich unter Verwendung der (auf Basis der Variable Importance) wichtigsten Prädiktoren ein gleich gutes Ergebnis erzielt werden kann, wie mit dem gefitteten einfachen Baummodell.


<details>
  <summary>Code Details</summary>
```{r load model}
if (file.exists("neuronale_netze.RData"))
  load("neuronale_netze.RData")
```
</details>

Definition von allgemeinen Funktionen
```{r, output='hide'}
maxidx <- function(arr) {
    return(which(arr == max(arr)))
}

normalize <- function(x) {
  return ((x - min(x)) / (max(x) - min(x)))
}
```

### Neuronales Netz für Hunde

Wie auch bei den Decision Trees wird pro Tierrasse ein Modell mit denselben Parametern wie für die anderen Tierrassen gefittet. 

Modellfitting unter Verwendung aller Variablen (normalisiert) außer Breed: 
```{r NN dogs, output='hide'}
set.seed(seed_val)

#Normalisierung der numerischen Variablen (Spalten 2-5)
training_dog_norm = training_dog
training_dog_norm[c(2:5)] <- as.data.frame(lapply(training_dog_norm[c(2:5)], normalize))

testing_dog_norm = testing_dog
testing_dog_norm[c(2:5)] <- as.data.frame(lapply(testing_dog_norm[c(2:5)], normalize))


#'Fullmodel' Fitting

if (!exists("net_model_dog"))
  net_model_dog <- neuralnet(outcome_type_adopt ~ .,
                  data=training_dog_norm[c(2:78)], 
                  hidden=c(3),
                  stepmax = 1000000,
                  threshold = 1, 
                  linear.output=T,
                  act.fct = "logistic")
```

Modellfitting mit einer Teilmenge/ Auswahl von Variablen (Auswahl auf Basis der Feature Importance): 
```{r NN dogs selected Vars, output='hide'}

set.seed(seed_val)

if (!exists("net_model_dog_selected"))
  net_model_dog_selected <- neuralnet(outcome_type_adopt ~ time_in_shelter_days+sex_upon_intake_first_Sterilized,
                  data=training_dog_norm[c(2:78)], 
                  hidden=c(3),
                  stepmax = 1000000,
                  threshold = 1, 
                  linear.output=T,
                  act.fct = "logistic")
```

Visualisierung des neuronalen Netzes mit den wichtigen Features aus dem Decision Tree
```{r plot NN selected, echo=FALSE}
plot(net_model_dog_selected , rep="best")
```

Verlgeich der Accuracy der Modelle
```{r model accuracy1 }
#Vorhersage und De-Normalisierung für Modell mit allen Variablen 
pred_net_dog <- predict(net_model_dog,testing_dog_norm[c(2:5,7:78)])
idx <- apply(pred_net_dog, c(1), maxidx)
pred_net_dog <-as.factor(c('0', '1')[idx])

#Vorhersage und De-Normalisierung für Modell mit Teilmenge von Variablen 
pred_net_dog_selected <- predict(net_model_dog_selected,testing_dog_norm[c(2:5,7:78)])
idx <- apply(pred_net_dog_selected, c(1), maxidx)
pred_net_dog_selected <-as.factor(c('0', '1')[idx])

#Confusion Matrizen für beide Modelle 
cf_net_dog <- confusionMatrix(pred_net_dog,testing_dog_norm$outcome_type_adopt)
cf_net_dog_selected <- confusionMatrix(pred_net_dog_selected,testing_dog_norm$outcome_type_adopt)

cat("All Variables: Accuracy", cf_net_dog$overall["Accuracy"], "\n")
cat("Selected Variables: Accuracy", cf_net_dog_selected$overall["Accuracy"], "\n")
```

*Interpretation*

Die Accuracy 


### Neuronales Netz für Katzen
<details>
  <summary>Code Details</summary>
```{r model fitting cats}

set.seed(seed_val)

training_cat_norm = training_cat
training_cat_norm[c(2:5)] <- as.data.frame(lapply(training_cat_norm[c(2:5)], normalize))

testing_cat_norm = testing_cat
testing_cat_norm[c(2:5)] <- as.data.frame(lapply(testing_cat_norm[c(2:5)], normalize))


if (!exists("net_model_cat"))
  net_model_cat <- neuralnet(outcome_type_adopt ~ .,
                  data=training_cat_norm[c(2:78)], 
                  hidden=c(3),
                  stepmax = 1000000,
                  threshold = 1, 
                  act.fct = "logistic")
```
</details>

<details>
  <summary>Code Details</summary>
```{r model fitting selected vars1}
set.seed(seed_val)

if (!exists("net_model_cat_selected"))
  net_model_cat_selected <- neuralnet(outcome_type_adopt ~ sex_upon_outcome_first_Sterilized+age_upon_outcome_.days.+time_in_shelter_days,
                  data=training_cat_norm[c(2:78)], 
                  hidden=c(3),
                  stepmax = 1000000,
                  threshold = 1, 
                  act.fct = "logistic")
```
</details>

Visualisierung des neuronalen Netzes mit den wichtigen Features aus dem Decision Tree
```{r plot cats model, echo=FALSE}
plot(net_model_cat_selected , rep="best")
```

Verlgeich der Accuracy der Modelle
```{r, echo=FALSE}
pred_net_cat <- predict(net_model_cat,testing_cat_norm[c(2:5,7:78)] )
idx <- apply(pred_net_cat, c(1), maxidx)
pred_net_cat <-as.factor(c('0', '1')[idx])

cf_net_cat <- confusionMatrix(pred_net_cat,testing_cat_norm$outcome_type_adopt)

pred_net_cat_selected <- predict(net_model_cat_selected,testing_cat_norm[c(2:5,7:78)] )
idx <- apply(pred_net_cat_selected, c(1), maxidx)
pred_net_cat_selected <-as.factor(c('0', '1')[idx])

cf_net_cat_selected  <- confusionMatrix(pred_net_cat_selected,testing_cat_norm$outcome_type_adopt)

cat("All Variables: Accuracy", cf_net_cat$overall["Accuracy"], "\n")
cat("Selected Variables: Accuracy", cf_net_cat_selected$overall["Accuracy"], "\n")
```
*Interpretation*

### Neuronales Netz für Hasen

<details>
  <summary>Code Details</summary>
```{r modell fitting rabbits all vars}
set.seed(seed_val)
training_rabbit_norm = training_rabbit
training_rabbit_norm[c(2:5)] <- as.data.frame(lapply(training_rabbit_norm[c(2:5)], normalize))

testing_rabbit_norm = testing_rabbit
testing_rabbit_norm[c(2:5)] <- as.data.frame(lapply(testing_rabbit_norm[c(2:5)], normalize))


if (!exists("net_model_rabbit"))
  net_model_rabbit <- neuralnet(outcome_type_adopt ~ .,
                  data=training_rabbit[c(2:78)], 
                  hidden=c(3),
                  stepmax = 1000000,
                  threshold = 1, 
                  act.fct = "logistic")
```
</details>

<details>
  <summary>Code Details</summary>
```{r model fitting selected vars2}
set.seed(seed_val)
if (!exists("net_model_rabbit_selected"))
  net_model_rabbit_selected <- neuralnet(outcome_type_adopt ~ sex_upon_outcome_first_Sterilized,
                  data=training_rabbit[c(2:78)], 
                  hidden=c(3),
                  stepmax = 1000000,
                  threshold = 1, 
                  act.fct = "logistic")
```
</details>

Visualisierung des neuronalen Netzes mit den wichtigen Features aus dem Decision Tree
```{r model plot3, echo=FALSE}
plot(net_model_rabbit_selected , rep="best")
```

Verlgeich der Accuracy der Modelle
```{r compare models, echo=FALSE}
pred_net_rabbit <- predict(net_model_rabbit,testing_rabbit_norm[c(2:5,7:78)])
idx <- apply(pred_net_rabbit, c(1), maxidx)
pred_net_rabbit <-as.factor(c('0', '1')[idx])

pred_net_rabbit_selected <- predict(net_model_rabbit_selected,testing_rabbit_norm[c(2:5,7:78)])
idx <- apply(pred_net_rabbit_selected, c(1), maxidx)
pred_net_rabbit_selected <-as.factor(c('0', '1')[idx])

cf_net_rabbit <- confusionMatrix(pred_net_rabbit,testing_rabbit_norm$outcome_type_adopt)
cf_net_rabbit_selected <- confusionMatrix(pred_net_rabbit_selected,testing_rabbit_norm$outcome_type_adopt)
cat("All Variables: Accuracy", cf_net_rabbit$overall["Accuracy"], "\n")
cat("Selected Variables: Accuracy", cf_net_rabbit_selected$overall["Accuracy"], "\n")
```


```{r}
set.seed(123)
control <- trainControl(method = 'cv', number = 10)

nnet_model_rabbit <- train(outcome_type_adopt ~., data = training_rabbit_norm[2:78], method = 'nnet', trControl = control, tuneGrid=expand.grid(size=c(10), decay=c(0.1)), maxi = 100000 )

pred_nnet_rabbit <- predict(nnet_model_rabbit,testing_rabbit_norm[c(2:5,7:78)])
cf_nnet_rabbit <- confusionMatrix(pred_nnet_rabbit,testing_rabbit_norm$outcome_type_adopt)
cat("All Variables: Accuracy", cf_nnet_rabbit$overall["Accuracy"], "\n")
```

```{r}
imp_nn_s_rab = vi(class_model_nnet)
imp_nn_s_rab = imp_nn_s_rab[imp_nn_s_rab$Importance>5,]
imp_nn_s_rab_tab = tibble(Variable = imp_nn_s_rab$Variable, Importance = imp_nn_s_rab$Importance)
imp_nn_s_rab_tab
vip(class_model_nnet, width = 0.5, fill = "green3")
```

### Vergleich aller Neuronalen Netzwerke 

Tabelle der Accuracies aller neuronalen Netze
```{r accuracies, echo=FALSE}
accuracyTable = tibble(Tierart="Hunde", Accuracy_All=cf_net_dog$overall["Accuracy"], Accuracy_Selected_Features=cf_net_dog_selected$overall["Accuracy"])
accuracyTable = add_row(accuracyTable, Tierart="Katzen", Accuracy_All=cf_net_cat$overall["Accuracy"], Accuracy_Selected_Features=cf_net_cat_selected$overall["Accuracy"])
accuracyTable = add_row(accuracyTable, Tierart="Hasen", Accuracy_All=cf_net_rabbit$overall["Accuracy"], Accuracy_Selected_Features=cf_net_rabbit_selected$overall["Accuracy"])

kable(accuracyTable, align = "l") %>%
  kable_styling(bootstrap_options = "striped") %>%
  footnote(general = "", general_title = "Tabelle 1: Accuracies der Neuronalen Netze")

```

<details>
  <summary>Code Details</summary>
```{r save NN models}
if (!file.exists("neuronale_netze.RData"))
  save(net_model_dog, net_model_dog_selected, net_model_cat, net_model_cat_selected, net_model_rabbit,net_model_rabbit_selected, file = "neuronale_netze.RData")
```
</details>

#Conclusion

Das Vorgehen bei der Prädiktion hat zufriedenstellende Ergebnisse geliefert. Es konnten einerseits relevante Faktoren für die Adoption der am häufigsten im Tierheim vorhandenen Tierarten eruiert werden, andererseits konnten Neuronale Netze mit guter Accuracy (über 80%) gefittet werden. 

```{r}
accuracy_compare_table = tibble(Modell="Decision Tree", Hunde=conf_matrix_tree_dog1$overall["Accuracy"], Katzen=conf_matrix_tree_cat1$overall["Accuracy"], Hasen=conf_matrix_tree_rabbit1$overall["Accuracy"])

accuracy_compare_table = add_row(accuracy_compare_table, Modell="Neuronales Netz", Hunde=cf_net_dog$overall["Accuracy"], Katzen=cf_net_cat$overall["Accuracy"], Hasen=cf_net_rabbit$overall["Accuracy"])
```

```{r}
kable(accuracy_compare_table, align = "l") %>%
  kable_styling(bootstrap_options = "striped") %>%
  footnote(general = "", general_title = "Tabelle 2: Test Accuracies der Modelle")
```

Die anfangs formulierte Hypothese, dass die Adoption vor allem vom Alter und Gesundheitszustand abhängig ist, konnte nur teilweise verifiziert werden. Außerdem stellte sich heraus, dass für unterschiedliche Tierarten unterschiedliche Faktoren und in unterschiedlichem Ausmaß einen Einfluss auf die Adoptionswahrscheinlichkeit nehmen. Bei Hunden sind die Sterilisation, die Zeitdauer im Tierheim, das Alter und ob es sich um einen Streuner handelt die wichtigsten Kriterien. Für das Tierheim bedeutet das, dass durch eine Sterilization die Adoption wahrscheinlich am stärksten beeinflusst werden kann. 
Bei Katzen ist das Alter für die Adoption relevanter als bei Hunden, aber auch bei dieser Tierart spielt die Sterilization eine bedeutende Rolle, wie auch ob es sich um ein Streunertier handelt. 
Überraschend ist, dass der Gesundheitszustand in keinem der Modelle als relevant für eine Adoption bewertet wurde. 
Bei den Vorhersagen der Adoption von Hasen zeigte sich ein extremer Unterschied der relevanten Faktoren im Vergleich zu den Hunden und Katzen. Es scheint, als gäbe es eine "saisonale" Abhängigkeit für die Adoption, wir vermuten, dass z.B. um Feiertage (Ostern, Weihnachten), die Adoptionszahl für Hasen ansteigt. Das Tierheim könnte diese Information z.B. dazu nutzen, um die Auslastung/Belegung im Tierheim zu optimieren, da entweder in Zeiten, wo weniger Adoptionen eintreten, die Plätze kurzzeitig ausgebaut werden, da absehbar ist, wann diese wieder reduziert werden können. 


![](snoopy.png)
