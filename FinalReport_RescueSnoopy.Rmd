---
title: "Algorithmik & Statistik Lab 2: Finaler Bericht - 'Rescue Snoopy'"
author: "Lara Knapwost - 1810837601, Cornelia Reithmeier - 1810837362, Isabelle Veitl - 1810837521, Anna Weber - 1810837818"
date: '11. Juli 2019'
output: 
  html_document:
    toc: TRUE
urlcolor: cyan
---
***
Unter dem Arbeitstitel "Rescue Snoopy" wurden die unten beschriebenen Daten ausgewählt, analysiert, das statistische Analyse-Interesse dargelegt und dann mit Hilfe von Decision Tree und Neuronalen Netzwerk-Modellen durchgeführt.
Die gemeinsame Arbeit an diesem Projekt wurde über Github abgewickelt und dokumentiert: https://github.com/Co-Re/RescueSnoopy007
 

# Ausgewähltes Datenset
Für die Gruppenarbeit werden Daten von Kaggle verwendet:  
https://www.kaggle.com/aaronschlegel/austin-animal-center-shelter-intakes-and-outcomes#aac_intakes.csv

Von den dort gesammelten Daten wird folgende Datei verwendet: `aac_intakes_outcomes`

Das Datenset enthält unter anderem folgende Variablen:

* `animal_id` - eindeutige ID des Tieres
* `age_upon_outcome` - Alter des Tieres bei Outcome
* `date_of_birth` - Geburtsdatum des Tieres (geschätzt, wenn dieses nicht bekannt war)
* `outcome_subtype` - spezifische Beschreibung des Outcomes
* `outcome_type` - Art des Outcomes
* `datetime` - Datum und Uhrzeit des Outcomes
* `outcome_number` - Anzahl, wie oft ein Tier das Tierheim schon verlassen hat
* `sex_upon_outcome` - Geschlecht des Tieres und ob das Tier kastriert wurde
* `age_upon_intake` - Alter des Tieres bei Aufnahme in String-Format 
* `animal_type` - Tierart
* `breed` - Tierrasse
* `color` - Tierfarbe
* `datetime` - Datum und Uhrzeit der Aufnahme
* `found_location` - Adresse oder Bereich, wo das Tier gefunden wurde 
* `intake_condition` - Zustand des Tieres bei der Aufnahme
* `intake_type` - kategorisierter Aufnahmetyp
* `name` - Name des Tieres
* `sex_upon_intake` - Geschlecht des Tieres und ob das Tier kastriert wurde
* `intake_number` - Anzahl, wie oft ein Tier schon zum Tierheim gebracht wurde
* `time_in_shelter` - Zeit im Tierheim

Neben diesen Variablen existierten weitere, die beispielsweise Zeiträume in einem anderen Format darstellen.

## Hintergrundinformationen zum Datenset
Die Daten wurden vom [Austin Animal Center](http://www.austintexas.gov/department/aac) erhoben. Dieses Animal Center ist das größte Tierheim in den USA, in dem keine Tiere getötet werden und kann bis zu 18.000 Tiere pro Jahr aufnehmen. Es werden alle Arten von Tieren aufgenommen. Das Tierheim befindet sich im Travis County im US-Bundesstaat Texas. Die Daten werden im Rahmen der Austin Open Data Intitiative online bereitgestellt.  

Das Datenset enthält n = 79.672 Observationen und 41 Variablen.   
Die Daten stammen aus der Zeit zwischen Oktober 2013 bis April 2018 (Outcomes).  
Die Tiere sind zwischen 0-25 Jahre alt, der Median liegt bei 1 Jahr, die Geschlechtsverteilung männlicher und weiblicher Tiere liegt fast bei 50/50.  
Mehr als die Hälfte der Tiere sind Hunde, gefolgt von Katzen und einigen Vögeln (<500). Etwa 4.500 Tiere sind keiner Spezies zugeordnet.   
Knapp die Hälfte der im Datenset enthaltenen Tiere wurde adoptiert.   

## Statistische Lernaufgabe
Im Rahmen der Gruppenarbeit soll ein Klassifikationsproblem betrachtet werden:

Vorhersage des Outcome-Types auf Basis der gegebenen Variablen. Die initale Idee war es, die Prädiktoren zu finden, anhand derer eine Rückgabe an den Besitzer, ein Transfer / eine Adoption, Euthanasie, Tod etc. möglichst genau (durch Vorhersage der Klasse) vorhergesagt werden können. Im Zuge des Preprocessings und nach detaillierten Auseinandersetzungen stellte sich heraus, dass für viele der angeführten Outcome-Typen wenige Fälle vorhanden sind, sodass eine Modellierung ohne Overfitting schwierig erscheint. Deshalb wurde während des Projektes bzw. zu Ende des Preprocessings der Datensatz auf Tierarten mit mindestens n=500 eingeschränkt und ausschließlich der Outcome-Type *Adoption* verwendet. 

## Motivation
Es gibt viele Tierheime und durch Hörensagen ist bekannt, dass in vielen davon eine Großzahl der Tiere einen beträchtlichen Teil ihres Lebens verbringen. 
Es ist interessant für uns, herauszufinden, welche Aspekte ausschlaggebend dafür sind, ob das Tier (vor dem Tod) wieder aus dem Tierheim "entlassen" wird, d.h. einen neuen Besitzer findet. Wir haben einige Hypothesen, welche wir prüfen möchten. Wir gehen davon aus, dass vor allem jüngere, gesunde Tiere eine bessere Chance haben, als ältere, kranke, ggf. auch nicht kastrierte (Streuner-)Tiere, die bereits sehr lange im Tierheim sind.   
Weiß man, welche Aspekte eine Rolle spielen, könnte man diese gezielt in den Tierheimen in der Kommunikation verwenden, um mehr Tieren (z.B. vor allem jenen, die grundsätzlich eine schlechtere Chance für eine Adoption haben) ein neues zu Hause zu geben. Außerdem könnten die Modelle das Tierheim in der Planung (z.B. der verfügbaren Plätze) unterstützen.   
Wir haben uns für dieses Datenset mit dieser Fragestellung entschieden, da einige von uns selbst Haustiere besitzen und wir den Eindruck haben, dass es bereits ausreichend viele Analysen zu ökonomischen Fragestellungen gibt.

***

# Initiales Preprocessing


```{r load packages, include=F, message=FALSE, warning = FALSE}
pacman::p_load(
plyr, 
anytime,
lubridate,
kableExtra, 
caret,
rpart.plot,
dummies,
dplyr,
neuralnet,
tibble,
vip,
labeling,
captioner,
e1071,
ggplot2,
ggcorrplot)
```

```{r table_caption_init, results='hide', echo=FALSE}
table_nums <- captioner(prefix = "Tabelle")
```

## Laden der Daten
```{r load data, results='hide'}
aac_intakes_outcomes = read.csv("aac_intakes_outcomes.csv")
```

## Überprüfung der Datenstruktur
<details>
  <summary>Code Details</summary>
```{r check structure}
str(aac_intakes_outcomes)
# Andrucken der ersten Datensätze
head(aac_intakes_outcomes)
```
</details>
<details>
  <summary>Code Details</summary>
```{r summary1}
summary(aac_intakes_outcomes)
```
</details>

### Visualisierung der Verteilung numerischer Features

```{r hist,fig.align='center', fig.width=10,  fig.height = 8, echo=FALSE}
p1 <- qplot(aac_intakes_outcomes$age_upon_outcome_.days., geom="histogram", ylab = "", xlab = "age_upon_outcome_.days.", bins=30)
p2 <- qplot(aac_intakes_outcomes$age_upon_intake_.days., geom="histogram", ylab = "", xlab = "age_upon_intake_.days", bins=30)
p3 <- qplot(aac_intakes_outcomes$age_upon_outcome_.years., geom="histogram", ylab = "", xlab = "age_upon_outcome_.years.", binwidth=0.5)
p4 <- qplot(aac_intakes_outcomes$age_upon_intake_.years., geom="histogram", ylab = "", xlab = "age_upon_intake_.years.", binwidth=0.5)
p5 <- qplot(aac_intakes_outcomes$outcome_month, geom="histogram", ylab = "", xlab = "outcome_month", binwidth=0.5)
p6 <- qplot(aac_intakes_outcomes$intake_month, geom="histogram", ylab = "", xlab = "intake_month", binwidth=0.5)
p7 <- qplot(aac_intakes_outcomes$outcome_year, geom="histogram", ylab = "", xlab = "outcome_year", binwidth=0.5)
p8 <- qplot(aac_intakes_outcomes$intake_year, geom="histogram", ylab = "", xlab = "intake_year", binwidth=0.5)
p9 <- qplot(aac_intakes_outcomes$outcome_hour, geom="histogram",  ylab = "", xlab = "outcome_hour", binwidth=0.5)
p10 <- qplot(aac_intakes_outcomes$intake_hour, geom="histogram", ylab = "", xlab = "intake_hour", binwidth=0.5)
p11 <- qplot(aac_intakes_outcomes$outcome_number, geom="histogram", ylab = "", xlab = "outcome_number", binwidth=0.5)
p12 <- qplot(aac_intakes_outcomes$intake_number, geom="histogram",  ylab = "", xlab = "intake_number", binwidth=0.5)
p13 <- qplot(aac_intakes_outcomes$dob_year, geom="histogram",  ylab = "", xlab = "dob_year", binwidth=0.5)
p14 <- qplot(aac_intakes_outcomes$dob_month, geom="histogram",  ylab = "", xlab = "dob_month", binwidth=0.5)
p15 <- qplot(aac_intakes_outcomes$time_in_shelter_days, geom="histogram", ylab = "", xlab = "time_in_shelter_days", bins=30)

grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15)
```

Interpretation der Daten:

* Die Verteilung der Daten in den Variablen `age_upon_outcome` und `age_upon_intake` ist relativ ähnlich. Es werden kaum ältere Tiere (über 2 Jahre) ins Tierheim gebracht sowie aus dem Tierheim entnommen. Ein Großteil der Tiere ist sowohl bei der Einlieferung als auch bei der Entlassung jünger als ca. 1 Jahr. Anhand der Summary ist auch zu sehen, dass es negative Altersangaben gibt (hierauf wird später noch Bezug genommen).  Bei der Betrachtung der Altersangabe in Tagen ist ersichtlich, dass es sowohl bei den Intakes als auch den Outcomes fehlende Werte an denselben Stellen gibt. Woher dies resultiert, sollte mit dem Tierheim abgeklärt werden.
* Die Verteilung der Daten in der Variable `time_in_shelter` zeigt, dass die meisten Tiere zwischen 0 und 100 Tage im Tierheim verbringen.
* Die Verteilung von `dob_month` ist recht gleichmäßig, es gibt lediglich kleine Ausschläge zwischen März, April und Mai. Der leichte Anstieg im Frühjahr der zu erkennen ist, ist wahrscheinlich darauf zurückzuführen , dass in diese Jareszeit die Hauptpaarungszeit vieler Tierarten fällt. 
* Die Daten zeigen hauptsächlich Informationen der Jahre 2014 bis 2017. Es würde ggfs. Sinn machen, die Jahre 2013 und 2018 auszuschließen, da hier vergleichsmäßig wenige Daten vorhanden sind.
* Die Verteilung der Variable `outcome_hour` zeigt, dass ab ca. 6 Uhr Tiere aus dem Tierheim entlassen werden. Diese Zahlen steigen - mit Ausnahme von 9 - 10 Uhr - an, bis der Höhepunkt von 16 bis 17 Uhr erreicht ist. Dass am Nachmittag die meisten Tiere abgeholt werden, erscheint unter der Berücksichtigung einer normalen Arbeitszeit plausibel. 
* Die Verteilung der Variable `intake_hour` zeigt eher das Gegenteil von `outcome_hour`. Recht wenig Tiere werden vor 10 Uhr ins Tierheim gebracht, dann erfolgt ein recht rasanter Anstieg auf den Höhepunkt zwischen 10 und 11 Uhr. Nach 11 Uhr nimmt die Anzahl an Tieren, die ins Tierheim gebracht werden, wieder langsam ab. 
* Sowohl die `outcome_number` als auch die `intake_number`, also die Anzahl, wie häufig ein Tier ins Tierheim gebracht bzw. wieder abgeholt wurde, zeigen fast nur Werte unter 4 und hierbei auch nur einen minimalen Anteil größer 1. Demnach kommt die überwiegende Mehrheit der Tiere nur ein Mal ins Tierheim.
* Die Verteilung von `dob_year` zeigt, dass die meisten Tiere zwischen ca. 2012 und 2015 geboren sind. Dies steht ein wenig im Gegensatz zu den Altersangaben. Da jedoch Altersangaben teilweise geschätzt werden, können hiermit Abweichungen geklärt werden.

```{r corr, echo=FALSE}
cor_data <- aac_intakes_outcomes[c(7,8,11,12,15:18,30,31,34,35,38,39,41)]
corr_matrix <- round(cor(cor_data),1)
ggcorrplot(corr_matrix)
```

In der Korrelationsmatrix sind u.a. folgende Korrelationen erkennbar, die uns bei der Bewertung der Datenqualität helfen. Obwohl einzelne fehlende Werte erkannt wurden, zeigen die folgenden Korrelationen doch deutlich, dass die Daten grundsätzlich plausible Korrelationen aufweisen:

* `age_upon_intake_years` korreliert stark positiv mit `age_upon_intake_days`. Dies ist offensichtlich, da es sich um dieselben Daten, lediglich in einer anderen Einheit handelt. Dasselbe gilt für `age_upon_outcome_years` und `age_upon_outcome_days`.
* Der `intake_month` korreliert recht stark positiv mit dem `outcome_month`.
* Selbiges gilt für das `intake_year` und das `outcome_year`. Hier ist die Korrelation sogar noch stärker. Auch dies erscheint logisch, als Dies zeigt, dass die meisten Tiere wohl im selben Jahr in das Tierheim kommen sowie wieder aus dem Tierheim kommen.
* Das Geburtsjahr korreliert logischerweise stark negativ mit dem Alter bei Intake: umso kleiner das Geburtsjahr, desto älter das Tier und umgekehrt.

Die statistische Analyse der kategorialen Variablen findet im Rahmen der folgenden Datenbereinigungsschritte statt.

### Datenbereinigung I - Konvertieren der Datentypen
```{r datatypes}
aac_intakes_outcomes$animal_id_outcome <- as.character(aac_intakes_outcomes$animal_id_outcome)
aac_intakes_outcomes$date_of_birth <- anytime(aac_intakes_outcomes$date_of_birth)

aac_intakes_outcomes$sex_upon_outcome[is.na(aac_intakes_outcomes$sex_upon_outcome)] <- "Unknown"
aac_intakes_outcomes$sex_upon_outcome[is.element(aac_intakes_outcomes$sex_upon_outcome, "NULL")] <- "Unknown"
aac_intakes_outcomes$sex_upon_outcome_first <- as.factor(sapply(strsplit(as.character(aac_intakes_outcomes$sex_upon_outcome), " "), "[", 1))
aac_intakes_outcomes$sex_upon_outcome_second <- sapply(strsplit(as.character(aac_intakes_outcomes$sex_upon_outcome), " "), "[", 2)
aac_intakes_outcomes$sex_upon_outcome_second[is.na(aac_intakes_outcomes$sex_upon_outcome_second)] <- "Unknown"
aac_intakes_outcomes$sex_upon_outcome_second <- as.factor(aac_intakes_outcomes$sex_upon_outcome_second)

aac_intakes_outcomes$age_upon_outcome_.days. <- as.numeric(aac_intakes_outcomes$age_upon_outcome_.days.)
aac_intakes_outcomes$outcome_datetime <- anytime(aac_intakes_outcomes$outcome_datetime)
aac_intakes_outcomes$outcome_month <- as.factor(aac_intakes_outcomes$outcome_month)
aac_intakes_outcomes$outcome_year <- as.factor(aac_intakes_outcomes$outcome_year)
aac_intakes_outcomes$outcome_hour <- as.factor(hour(aac_intakes_outcomes$outcome_datetime))
aac_intakes_outcomes$dob_month <- as.factor(aac_intakes_outcomes$dob_month)
aac_intakes_outcomes$dob_year <- as.factor(aac_intakes_outcomes$dob_year)
aac_intakes_outcomes$animal_id_intake <- as.character(aac_intakes_outcomes$animal_id_intake)

aac_intakes_outcomes$sex_upon_intake[is.na(aac_intakes_outcomes$sex_upon_intake)] <- "Unknown"
aac_intakes_outcomes$sex_upon_intake_first <- as.factor(sapply(strsplit(as.character(aac_intakes_outcomes$sex_upon_intake), " "), "[", 1))
aac_intakes_outcomes$sex_upon_intake_second <- sapply(strsplit(as.character(aac_intakes_outcomes$sex_upon_intake), " "), "[", 2)
aac_intakes_outcomes$sex_upon_intake_second[is.na(aac_intakes_outcomes$sex_upon_intake_second)] <- "Unknown"
aac_intakes_outcomes$sex_upon_intake_first[is.na(aac_intakes_outcomes$sex_upon_intake_first)] <- "Unknown"
aac_intakes_outcomes$sex_upon_intake_second <- as.factor(aac_intakes_outcomes$sex_upon_intake_second)

aac_intakes_outcomes$count <- as.numeric(aac_intakes_outcomes$count)
aac_intakes_outcomes$age_upon_intake_.days. <- as.numeric(aac_intakes_outcomes$age_upon_intake_.days.)
aac_intakes_outcomes$intake_datetime <- anytime(aac_intakes_outcomes$intake_datetime)
aac_intakes_outcomes$intake_month <- as.factor(aac_intakes_outcomes$intake_month)
aac_intakes_outcomes$intake_year <- as.factor(aac_intakes_outcomes$intake_year)
aac_intakes_outcomes$intake_hour <- as.factor(hour(aac_intakes_outcomes$intake_datetime))
```

### Anmerkungen für weitere Preprocessing Schritte

Folgende Animal-Types sind vorhanden:
```{r table animals, echo=FALSE}
table(aac_intakes_outcomes$animal_type)
```

Unter Other verbergen sich großteils unterschiedliche Nage- und Säugetiere bzw. Kleintiere, die in einem folgenden Datenaufbereitungsschritt feingliedriger aufgedrosselt werden.

Folgende Kombinationen sind bei der Zeugungsfähigkeit des Geschlechts möglich, wobei in den Zeilen der Zustand bei Aufnahme im Tierheim dargestellt wird, in den Spalten der Zustand beim Verlassen:

```{r crosstable1, echo=FALSE}
table(aac_intakes_outcomes$sex_upon_intake_first, aac_intakes_outcomes$sex_upon_outcome_first) 

```
Unplausible Fälle (kastrierter Income, nichtkastrierter Outcome) werden im Zuge der Datenaufbereitung zu Unknown rekategorisiert.


### Erstellung eines neuen Datasets und Entfernung von Variablen
Das neue Dataset enthält nicht alle Variablen. 
Die Outcome-Zeitdaten wurden in diesem Projekt bewusst in die Modellierung miteinbezogen, um zB vorzusagen ob ein Tier im aktuellen Monat adoptiert werden wird.

<details>
  <summary>Code Details</summary>
```{r create new dataframe}
aac_intakes_outcomes2 <- aac_intakes_outcomes[c(5, 22:24, 26, 27, 43, 42, 44, 3, 17, 18, 33:35, 39, 10:12, 30, 7, 40, 41)]
```
</details>

Im Folgenden findet sich eine Auflistung der entfernten Variablen, sowie eine Begründung, weshalb einige Daten nicht für die Analyse miteinbezogen werden. 
Folgende Variablen wurden für das neue Dataset nicht verwendet:

* `found_location` - Diese Variable bietet keine gute Datenqualität, es sind nicht immer gleiche Daten erfasst (z.B. manchmal Ortsname, manchmal komplette Adresse). Eine Bereinigung bzw. Kürzung auf den Ortsnamen bringt keinen Erkenntnisgewinn für das Modell, da alle Aufnahmen in derselben Region stattfanden und einzig über die Adressangabe Subregionen miteinander vergleichbar wären. 
* `sex_upon_intake` - Diese Variable enthält die selben Daten wie `sex_upon_intake`, ist daher redundant.

```{r crosstable2, echo=FALSE, results='hide'}
table(aac_intakes_outcomes$sex_upon_intake_second, aac_intakes_outcomes$sex_upon_outcome_second)
```

* `outcome_subtype` - Diese Variable enthält nur für sehr wenige Datensätze zusätzliche Informationen, diese sind nicht durchgängig je `Outcome_type` befüllt. Außerdem ist die Kategorisierung nicht gänzlich diskriminant, da z.B. Aggressive eine Teilkategorie von Behavior wäre, wobei nicht klar ist, welches Verhaltensmuster dann in Behavior erfasst wurde bzw. ob dieses mit aggressivem Verhalten gleichzusetzen ist. 

```{r crosstable3, echo=FALSE}
table(aac_intakes_outcomes$outcome_subtype, aac_intakes_outcomes$outcome_type)
```

* `animal_id_outcome` - ID kann nicht für Klassifikation verwendet werden.
* `sex_upon_outcome` - Diese Variable wurde gesplittet, die neuen Variablen werden verwendet
* `outcome_monthyear` - Der Monat und das Jahr werden als einzelne Variablen verwendet. Diese Ursprungsvariable wird damit nicht mehr benötigt.
* `outcome_hour` - Es werden auch zu ungewöhnlichen Uhrzeiten (z.B. Mitternacht) Geschäftsfälle registriert, welche nicht plausibel erscheinen. 

```{r crosstable4, echo=FALSE}
table(aac_intakes_outcomes$outcome_hour)
```

* `dob_monthyear` - Geburtsdatum. Der Monat und das Jahr werden als einzelne Variablen verwendet. Diese Ursprungsvariable wird damit nicht mehr benötigt.
* `animal_id_intake` - ID kann nicht für Klassifikation verwendet werden
* `count` - alle Werte sind 1 (Aushilfsspalte) d.h. kein Informationsgewinn durch diese Variable

```{r table1, echo=FALSE, results='hide'}
table(aac_intakes_outcomes$count)
```

* `intake_monthyear` - der Monat und das Jahr werden als einzelne Variablen verwendet
* `intake_hour` - Es werden auch zu ungewöhnlichen Uhrzeiten Geschäftsfälle registriert, welche unplausibel erscheinen.

```{r table2, echo=FALSE}
table(aac_intakes_outcomes$intake_hour)
```

* `outcome_weekday`, `intake_weekday` - es soll keine Klassifikation auf Basis eines Wochentages gemacht werden.
* `outcome_number` - Diese Variable enthält dieselben Informationen wie `intake_number`, ist daher redundant.

```{r table3, echo=FALSE, results='hide'}
table(aac_intakes_outcomes$outcome_number, aac_intakes_outcomes$intake_number)
```

* `age_upon_intake`, `age_upon_intake_year` - Diese Variablen enthalten dieselben Informationen wie age_upon_intake_days.
* `age_upon_intake_group` - Die Gruppierung liefert keinen Mehrwert, da darin nicht die extrem variierende Lebenserwartung in Abhängigkeit der Tierart berücksichtigt wird.
* `age_upon_outcome`, `age_upon_outcome_year` - Diese Variablen enthalten dieselben Informationen wie `age_upon_outcome_days`.
* `age_upon_outcome_group` - Die Gruppierung liefert keinen Mehrwert, da darin nicht die extrem variierende Lebenserwartung in Abhängigkeit der Tierart berücksichtigt wird.


# Preprocessing II

## Prüfung auf fehlende Werte

Über die Summary wird geprüft, wo fehlende Werte vorkommen.
```{r summary2, results='hide'}
summary(aac_intakes_outcomes2)
```

Für die Prüfung werden zuerst alle Ausprägungen der Response `outcome_type` angesehen und bereinigt. 
```{r check uniques}
unique(aac_intakes_outcomes2$outcome_type)
table(aac_intakes_outcomes2$outcome_type)
```

```{r clean outcometype,  results='hide'}
v = as.vector(which(aac_intakes_outcomes2$outcome_type == ""))
aac_intakes_outcomes2 <- aac_intakes_outcomes2[-v,]
aac_intakes_outcomes2$outcome_type <- factor(aac_intakes_outcomes2$outcome_type)
```


## Anpassen des Animal Types Other

Auf Basis der Breed Variable wird die fehlende Information der Tierrasse (Ausprägung Other, 4423 Beobachtungen) aufgefüllt. 

<details>
  <summary>Code Details</summary>
```{r}
others = aac_intakes_outcomes2[aac_intakes_outcomes2$animal_type  == "Other", ] 
```
</details>

```{r count others, echo=TRUE, fig.cap = "Anzahl der Tiere, deren Animaltype Information fehlt"}
count(others)
```


<details>
  <summary>Code Details</summary>
```{r recode animal_type}

# Erstellen eines csv files um die verschiedenen Rassen Tieren zuordnen zu können 
# write.csv(count(others$breed), file = "breed.csv", append = FALSE, quote = TRUE, sep = " ",
#             eol = "\n", na = "NA", dec = ".", row.names = TRUE,
#             col.names = TRUE, qmethod = c("escape", "double"),
#             fileEncoding = "")

# Entfernen von "Mix"
new_animal_type <- gsub(" Mix","",others$breed)

#Ersetzen aller Rassen die Rabbit enthalten
new_animal_type <-
gsub("(.*)?Rabbit(.*)?", "Rabbit", new_animal_type)

# Ersetzen aller Rassen die Rabbit Rassen sind
rabbit_pattern <-
"(American Sable|Angora|Belgian Hare|Britannia Petit|Californian|Checkered Giant|Cinnamon|Cottontail|Dutch|English Spot|Flemish Giant|Harlequin|Havana|Himalayan|Hotot|Jersey Wooly|Lionhead|Lop|Netherlnd Dwarf|New Zealand Wht|Rex|Ringtail|Silver|Polish)"
rabbit_pattern <- paste("(.*)?", rabbit_pattern, "(.*)?", sep = "")
new_animal_type <- gsub(rabbit_pattern, "Rabbit", new_animal_type)

# Gerbil mit Mouse ersetzen
new_animal_type <- gsub("(.*)?Gerbil(.*)?", "Mouse", new_animal_type)

# Chinchilla
new_animal_type <- gsub("(.*)?Chinchilla(.*)?", "Chinchilla", new_animal_type)

# Snake
new_animal_type <- gsub("(.*)?Snake(.*)?", "Snake", new_animal_type)

# Pig
new_animal_type <- gsub("(.*)?Pig(.*)?", "Pig", new_animal_type)

# Fish
new_animal_type <- gsub("(.*)?Cold Water(.*)?", "Fish", new_animal_type)

# Ersetzen von Rassen, die nicht bekannt sind, mit "Other"
new_animal_type <- gsub("(.*)?(American|Tropical)(.*)?", "Other", new_animal_type)

others$animal_type = new_animal_type

# Ersetzen der Animaltypen für Other in der Original Tabelle

tmp_aac<- aac_intakes_outcomes2

tmp_aac$animal_type = as.character(tmp_aac$animal_type)

typeof(others$animal_type)
typeof(tmp_aac$animal_type)
tmp_aac[tmp_aac$animal_type  == "Other", ] = others

aac_intakes_outcomes2 = tmp_aac

aac_intakes_outcomes2$animal_type <- as.factor(aac_intakes_outcomes2$animal_type)

```
</details>

Nach Anreicherung durch Informationen aus `breed` und Bereinigung  liegt folgende Verteilung der Variable `animal_type`vor:
```{r after cleaning animaltype, echo=FALSE}
table(aac_intakes_outcomes2$animal_type)
```



## Anpassen der Animal Color

Um die Anzahl der Ausprägungen, welche im Originaldatenset hoch ist (knapp 100 verschiedene Farben), zu reduzieren, werden ähnliche Farben agreggiert. 
```{r table4, results='hide' }
sort(table(aac_intakes_outcomes2$color),decreasing=T)
```

<details>
  <summary>Code Details</summary>
```{r clean color}
#Zusammenfassen der Farben 
aac_intakes_outcomes2$color_new <-
gsub("Brown/Brown|Sable|Chocolate|Agouti|Liver", "Brown", aac_intakes_outcomes2$color)
aac_intakes_outcomes2$color_new <- gsub("(Black/Black)", "Black",aac_intakes_outcomes2$color_new)
aac_intakes_outcomes2$color_new <- gsub("(White/White)", "White",aac_intakes_outcomes2$color_new)
aac_intakes_outcomes2$color_new <- gsub("(Gold/Gold)", "Gold",aac_intakes_outcomes2$color_new)
aac_intakes_outcomes2$color_new <- gsub("(Yellow/Yellow)", "Yellow",aac_intakes_outcomes2$color_new)
aac_intakes_outcomes2$color_new <- gsub("(Cream|Tan|Gold|Lynx|Buff|Fawn)", "Beige",aac_intakes_outcomes2$color_new)
  
#Zusammenfassen von Multicolor-Farben
aac_intakes_outcomes2$color_new <-
gsub("(.*)?/(.*)?", "Multicolor", aac_intakes_outcomes2$color_new)
aac_intakes_outcomes2$color_new <- gsub("(Tricolor|Tortie|Calico|Torbie|Seal)", "Multicolor",aac_intakes_outcomes2$color_new)

#Entfernen von  non-color Information
aac_intakes_outcomes2$color_new <- gsub(" Tabby| Point| Merle| Smoke| Tick| Brindle| Tiger", "", aac_intakes_outcomes2$color_new)
aac_intakes_outcomes2$color_new <-
gsub("(.*)? (.*)", "Multicolor", aac_intakes_outcomes2$color_new)

aac_intakes_outcomes2$color_new <-
gsub("Flame", "Orange", aac_intakes_outcomes2$color_new)

aac_intakes_outcomes2$color_new <- as.factor(aac_intakes_outcomes2$color_new)
aac_intakes_outcomes2 <- aac_intakes_outcomes2[,-4]

```
</details>

Nach Bereinigung der Variable konnte die Anzahl an Farben extrem reduziert werden:
```{r table5, echo= FALSE}
table(aac_intakes_outcomes2$color_new)
```

## Neuberechnung der Altersangaben und Tage im Tierheim 

Da die bestehenden Alters-/Zeitangaben teilweise nicht mit den Datumsangaben übereingestimmt haben, werden diese neu berechnet bzw. überprüft.
Beim Alter bei Intake bzw. Outcome kommen dabei auch negative Werte vor. Zum Teil kann darauf geschlossen werden, dass das trächtige Muttertier vor der Geburt eingeliefert wurde und somit das Alter des Nachwuchs beim Intake im Minusbereich lag. In diesen Fällen wird es auf 0 gesetzt. Andere unschlüssige Fälle werden exkludiert.

<details>
  <summary>Code Details</summary>
```{r calculate age}
# Age upon intake
dtime <- round(difftime(aac_intakes_outcomes2$intake_datetime, aac_intakes_outcomes2$date_of_birth,
         units = c("days")))
aac_intakes_outcomes2$age_upon_intake_days_calc <- dtime

# Age upon outcome
dtime2 <- round(difftime(aac_intakes_outcomes2$outcome_datetime, aac_intakes_outcomes2$date_of_birth,
         units = c("days")))
aac_intakes_outcomes2$age_upon_outcome_days_calc <- dtime2

# Time in shelter
dtime3 <- round(difftime(aac_intakes_outcomes2$outcome_datetime, aac_intakes_outcomes2$intake_datetime,
         units = c("days")), digits = 5)
aac_intakes_outcomes2$time_in_shelter_days_calc <- dtime3

# Alle überflüssigen Features entfernen, die nun nicht mehr benötigt werden
aac_intakes_outcomes2[ ,c('age_upon_intake_.days.', 'age_upon_outcome_.days.', 'time_in_shelter_days', 'date_of_birth', 'intake_datetime', 'outcome_datetime')] <- list(NULL)

# Spalten umbennen
names(aac_intakes_outcomes2)[names(aac_intakes_outcomes2) == "age_upon_outcome_days_calc"] <- "age_upon_outcome_.days."
names(aac_intakes_outcomes2)[names(aac_intakes_outcomes2) == "age_upon_intake_days_calc"] <- "age_upon_intake_.days."
names(aac_intakes_outcomes2)[names(aac_intakes_outcomes2) == "time_in_shelter_days_calc"] <- "time_in_shelter_days"

# Negatives Alter exkludieren bzw. auf Null setzen
aac_intakes_outcomes_temp1 <- 
  aac_intakes_outcomes2[aac_intakes_outcomes2$age_upon_intake_.days.  >= -46 &
                        aac_intakes_outcomes2$age_upon_outcome_.days.  >= 0, ]
aac_intakes_outcomes2 <- aac_intakes_outcomes_temp1

aac_intakes_outcomes2$age_upon_intake_.days.[aac_intakes_outcomes2$age_upon_intake_.days.< 0] <- 0


#Löschen der alten Variable time_in_shelter

aac_intakes_outcomes2$time_in_shelter <- NULL

```
</details>

<details>
  <summary>Code Details</summary>
```{r check recodings2}
# Kontrolle, dass Alter bei Outcome immer höher ist als bei Intake
aac_intakes_outcomes_temp2 <- 
  aac_intakes_outcomes2[aac_intakes_outcomes2$age_upon_intake_.days. >
                        aac_intakes_outcomes2$age_upon_outcome_.days., ]
```
</details>

## Anpassen der Zeugungsfähigkeit

Bei Analyse der Daten wurde bemerkt, dass 3 Beobachtungen bei den Geschlechtsmerkmalen fehlerhaft sein müssen, da Intake und Outcome-Wert nicht zusammengepasst haben (siehe oben bei Anmerkungen zu Datenset). Bei diesen Beobachtungen war das Merkmal bei Intake Neutered/Spayed und bei Outcome Intact. Es wurde daher entschieden, dass diese Datensätze behalten werden und die Werte durch "Unknown" ersetzt werden.   
Da Neutered und Spayed unterschiedliche Wordings für die Sterilisation der weiblichen bzw. männlichen Tiere sind, wurden diese vereinheitlicht in der Ausprägung "Sterilized" zusammengefasst.

<details>
  <summary>Code Details</summary>
```{r recode sterilized}
detectwrong <- function(v1,c1,v2,c2,x) {ifelse((v1==c1)&(v2==c2),"Unknown",x)}

aac_intakes_outcomes2$sex_upon_intake_first_new <- detectwrong(
  aac_intakes_outcomes2$sex_upon_intake_first,
  "Neutered",
  aac_intakes_outcomes2$sex_upon_outcome_first,
  "Intact",
  detectwrong(
    aac_intakes_outcomes2$sex_upon_intake_first,
    "Spayed", 
    aac_intakes_outcomes2$sex_upon_outcome_first, 
    "Intact", 
    as.character(aac_intakes_outcomes2$sex_upon_intake_first)
    )
  )

aac_intakes_outcomes2$sex_upon_outcome_first_new <- detectwrong(
  aac_intakes_outcomes2$sex_upon_intake_first,
  "Neutered", 
  aac_intakes_outcomes2$sex_upon_outcome_first,
  "Intact", 
  detectwrong(
    aac_intakes_outcomes2$sex_upon_intake_first,
    "Spayed", 
    aac_intakes_outcomes2$sex_upon_outcome_first, 
    "Intact", 
    as.character(aac_intakes_outcomes2$sex_upon_outcome_first)
    )
  )

# Zusammenfassung in "Sterilized"
aac_intakes_outcomes2$sex_upon_intake_first_new[aac_intakes_outcomes2$sex_upon_intake_first_new == "Neutered"] <- "Sterilized"
aac_intakes_outcomes2$sex_upon_intake_first_new[aac_intakes_outcomes2$sex_upon_intake_first_new == "Spayed"] <- "Sterilized"
aac_intakes_outcomes2$sex_upon_outcome_first_new[aac_intakes_outcomes2$sex_upon_outcome_first_new == "Neutered"] <- "Sterilized"
aac_intakes_outcomes2$sex_upon_outcome_first_new[aac_intakes_outcomes2$sex_upon_outcome_first_new == "Spayed"] <- "Sterilized"

# Kontrolle der Änderungen
table(aac_intakes_outcomes2$sex_upon_intake_first_new,aac_intakes_outcomes2$sex_upon_outcome_first_new)

# Als Faktor formatieren, Entfernen der alten Spalten und Umbenennen
aac_intakes_outcomes2$sex_upon_intake_first_new <- as.factor(aac_intakes_outcomes2$sex_upon_intake_first_new)
aac_intakes_outcomes2$sex_upon_outcome_first_new <- as.factor(aac_intakes_outcomes2$sex_upon_outcome_first_new)

aac_intakes_outcomes2[,c('sex_upon_intake_first', 'sex_upon_outcome_first')] <- list(NULL)

names(aac_intakes_outcomes2)[names(aac_intakes_outcomes2) == "sex_upon_intake_first_new"] <- "sex_upon_intake_first"
names(aac_intakes_outcomes2)[names(aac_intakes_outcomes2) == "sex_upon_outcome_first_new"] <- "sex_upon_outcome_first"
```
</details>


## Einschränkung der Tierarten 

```{r, echo=FALSE}
summary(aac_intakes_outcomes2$animal_type)

```
Da eine statistische Modellierung für Tierarten mit geringer Anzahl an Fällen nicht sinnvoll erscheint, wurde an dieser Stelle eine weitere Einschränkung des Datensatzes entschieden.

Der primäre Fokus der Vorhersage des Outcometypes soll nun bei Hunden und Katzen liegen. 
Jedoch sollen auch Tiere, von denen mind. n=500 Beobachtungen vorliegen, betrachtet werden, und zwar: 

* Dog: 45.364
* Cat: 29.536
* Bat:  2.205
* Raccoon: 706
* Rabbit: 513

Für jede Tierart soll ein eigenes Modell gefittet werden, gegebenenfalls müssen dann in weiterer Folge aufgrund zu geringer Fallzahlen die Tierarten weiter eingeschränkt werden. 

```{r remove animaltypes with too few cases, echo=FALSE}
aac_intakes_outcomes3<- data.frame(subset(aac_intakes_outcomes2, animal_type=="Dog"|animal_type=="Cat"|animal_type=="Bat"|animal_type=="Raccoon"|animal_type=="Rabbit"))


aac_intakes_outcomes2 <- aac_intakes_outcomes3
aac_intakes_outcomes2$animal_type <- factor(aac_intakes_outcomes2$animal_type)
summary(aac_intakes_outcomes2$animal_type)

```

### Verteilung der Y-Variable für verbleibende Tierarten
```{r plot1, echo=FALSE}
a<- ggplot(aac_intakes_outcomes2, aes(animal_type))+geom_bar(fill = "#0073C2FF") 

a+geom_bar(aes(fill = outcome_type))

```

<details>
  <summary>Code Details</summary>
```{r check numerics}
types <- table(aac_intakes_outcomes2$animal_type, aac_intakes_outcomes2$outcome_type)
types[order(types[,1], decreasing=T),]
```
</details>

## Einschränkung des OutcomeTypes

Da das Interesse des Tierheims vorallem darin liegt, dass Hunde, Katzen und Hasen *adoptiert* werden, und dieser Anteil auch bei den beiden Tierarten relativ hoch ist, d.h. ausreichend Daten zum Trainieren des Modells vorhanden sind, soll für diese Tierarten dieser *Outcometype* vorhergesagt werden. 

### Weitere Einschränkung nach Outcome Type und Tierart

Da der Anteil bei Wildtieren, die eingeschläfert werden, sehr hoch ist, liegen nur wenige Fälle für andere Outcome Types vor, weshalb an dieser Stelle davon abgesehen wird, Modelle für Racoons und Bats aufzustellen.  

Im Folgenden wird deshalb der Datensatz weiter reduziert (durch Entfernung der Wildtiere), es sollen ausschließlich Hunde, Katzen und Hasen verbleiben. Es wird eine neue Variable erstellt, die binär codiert angibt, ob das jeweilige Tier adoptiert wurde. 

<details>
  <summary>Code Details</summary>
```{r remove wild animals and dummycode adoption, warning=FALSE, message=FALSE}
#entferne wildtiere

aac_intakes_outcomes_3 <- subset(aac_intakes_outcomes2, animal_type  == "Dog" | animal_type == "Cat" | aac_intakes_outcomes2$animal_type  == "Rabbit")
aac_intakes_outcomes_3$animal_type <- factor(aac_intakes_outcomes_3$animal_type)

#dummycodierung für Adoption

dummies_outcometype <- data.frame(aac_intakes_outcomes_3$outcome_type)
dummies_outcometype <- dummy.data.frame(dummies_outcometype)

aac_intakes_outcomes_3$outcome_type_adopt <- dummies_outcometype[,1]

```
</details>

<details>
  <summary>Code Details</summary>
```{r check recoding2 and merge datasets, message=FALSE, warning=FALSE}
aac_intakes_outcomes_3$outcome_type <- factor(aac_intakes_outcomes_3$outcome_type)
table(aac_intakes_outcomes_3$outcome_type, aac_intakes_outcomes_3$outcome_type_adopt)

aac_intakes_outcomes2 <- aac_intakes_outcomes_3
```
</details>

### Adoptionen nach Tieren

Es liegen ausreichend Daten für die Vorhersage der Adoption vor. 

```{r}
b<- ggplot(aac_intakes_outcomes2, aes(animal_type))+geom_bar(fill = "#0073C2FF") 

b+geom_bar(aes(fill = outcome_type_adopt))

```

<details>
  <summary>Code Details</summary>
```{r table6}
t<-table(aac_intakes_outcomes2$outcome_type_adopt, aac_intakes_outcomes2$animal_type)
t

#Relative Anteile der Outcometypes
table<- prop.table(t,2)
```
</details>

<details>
  <summary>Code Details</summary>
```{r table7}
table(aac_intakes_outcomes2$animal_type, aac_intakes_outcomes2$outcome_type_adopt)
```
</details>

Da ein erster Testlauf/Fitting des Datensatzes mit einem Decision Tree aufgrund der Datenstrukturen (viele Variablen mit jeweils einer großen Anzahl an Ausprägungen, die die Berechnung der optimalen Splitpunkte dementsprechend beeinflusst) wenig performant ist, wurden die Daten überwiegend Dummycodiert um ein schnelleres Training zu erzielen. Bei der Dummycodierung wird für jede Ausprägung jeder Variable eine eigene Spalte angelegt, in der durch 0 bzw 1 angegeben wird, ob diese Ausprägung zutrifft oder nicht. Obwohl zwar damit die Anzahl an Features erhöht wird, kann doch die Trainingszeit verkürzt werden, da bei der Berechnung des Performance Indikators, anhand dessen der optimale Splitpunkt definiert wird, nur zwei, statt einer Vielzahl an Ausprägungen vorliegen. Damit kann der optimale Splitpunkt (anhand z.B. Entropy oder Gini Index in einem Kategorisierungsproblem) für jede Variable schneller gefunden werden.  

<details>
  <summary>Code Details</summary>
```{r recode dummies, warning=FALSE, message=FALSE}
#Löschung unbenötigter Spalten: outcometype (alle types) &date_of_birth_month & year

aac_intakes_outcomes2 <- aac_intakes_outcomes2[,c(2:6,9:20)]

#Dummycodierungen

dummies_intake_condition <- dummy.data.frame(data.frame(aac_intakes_outcomes2$intake_condition))
aac_intakes_outcomes2$intake_conditionAged <- dummies_intake_condition[,1]
aac_intakes_outcomes2$intake_conditionFeral <- dummies_intake_condition[,2]
aac_intakes_outcomes2$intake_conditionInjured <- dummies_intake_condition[,3]
aac_intakes_outcomes2$intake_conditionNormal <- dummies_intake_condition[,4]
aac_intakes_outcomes2$intake_conditionNursing <- dummies_intake_condition[,5]
aac_intakes_outcomes2$intake_conditionOther <- dummies_intake_condition[,6]
aac_intakes_outcomes2$intake_conditionPregnant <- dummies_intake_condition[,7]
aac_intakes_outcomes2$intake_conditionSick <- dummies_intake_condition[,8]

dummies_intake_type <- dummy.data.frame(data.frame(aac_intakes_outcomes2$intake_type))
aac_intakes_outcomes2$intake_typeEuthanasiaRequest <- dummies_intake_type[,1]
aac_intakes_outcomes2$intake_typeOwnerSurrender <- dummies_intake_type[,2]
aac_intakes_outcomes2$intake_typePublicAssist <- dummies_intake_type[,3]
aac_intakes_outcomes2$intake_typeStray <- dummies_intake_type[,4]
aac_intakes_outcomes2$intake_typeWildlife <- dummies_intake_type[,5]

dummies_suos <- dummy.data.frame(data.frame(aac_intakes_outcomes2$sex_upon_outcome_second))
aac_intakes_outcomes2$sexuponoutcomesecond_female <- dummies_suos[,1]
aac_intakes_outcomes2$sexuponoutcomesecond_male <- dummies_suos[,2]
aac_intakes_outcomes2$sexuponoutcomesecond_unknown <- dummies_suos[,3]

dummies_intake_month <- dummy.data.frame(data.frame(aac_intakes_outcomes2$intake_month))
aac_intakes_outcomes2$intake_month1 <- dummies_intake_month[,1]
aac_intakes_outcomes2$intake_month2 <- dummies_intake_month[,2]
aac_intakes_outcomes2$intake_month3 <- dummies_intake_month[,3]
aac_intakes_outcomes2$intake_month4 <- dummies_intake_month[,4]
aac_intakes_outcomes2$intake_month5 <- dummies_intake_month[,5]
aac_intakes_outcomes2$intake_month6 <- dummies_intake_month[,6]
aac_intakes_outcomes2$intake_month7 <- dummies_intake_month[,7]
aac_intakes_outcomes2$intake_month8 <- dummies_intake_month[,8]
aac_intakes_outcomes2$intake_month9 <- dummies_intake_month[,9]
aac_intakes_outcomes2$intake_month10 <- dummies_intake_month[,10]
aac_intakes_outcomes2$intake_month11 <- dummies_intake_month[,11]
aac_intakes_outcomes2$intake_month12 <- dummies_intake_month[,12]

dummies_intake_year <- dummy.data.frame(data.frame(aac_intakes_outcomes2$intake_year))
aac_intakes_outcomes2$intake_year2013 <- dummies_intake_year[,1]
aac_intakes_outcomes2$intake_year2014 <- dummies_intake_year[,2]
aac_intakes_outcomes2$intake_year2015 <- dummies_intake_year[,3]
aac_intakes_outcomes2$intake_year2016 <- dummies_intake_year[,4]
aac_intakes_outcomes2$intake_year2017 <- dummies_intake_year[,5]
aac_intakes_outcomes2$intake_year2018 <- dummies_intake_year[,6]

dummies_outcome_month <- dummy.data.frame(data.frame(aac_intakes_outcomes2$outcome_month))
aac_intakes_outcomes2$outcome_month1 <- dummies_outcome_month[,1]
aac_intakes_outcomes2$outcome_month2 <- dummies_outcome_month[,2]
aac_intakes_outcomes2$outcome_month3 <- dummies_outcome_month[,3]
aac_intakes_outcomes2$outcome_month4 <- dummies_outcome_month[,4]
aac_intakes_outcomes2$outcome_month5 <- dummies_outcome_month[,5]
aac_intakes_outcomes2$outcome_month6 <- dummies_outcome_month[,6]
aac_intakes_outcomes2$outcome_month7 <- dummies_outcome_month[,7]
aac_intakes_outcomes2$outcome_month8 <- dummies_outcome_month[,8]
aac_intakes_outcomes2$outcome_month9 <- dummies_outcome_month[,9]
aac_intakes_outcomes2$outcome_month10 <- dummies_outcome_month[,10]
aac_intakes_outcomes2$outcome_month11 <- dummies_outcome_month[,11]
aac_intakes_outcomes2$outcome_month12 <- dummies_outcome_month[,12]

dummies_outcome_year <- dummy.data.frame(data.frame(aac_intakes_outcomes2$outcome_year))
aac_intakes_outcomes2$outcome_year2013 <- dummies_outcome_year[,1]
aac_intakes_outcomes2$outcome_year2014 <- dummies_outcome_year[,2]
aac_intakes_outcomes2$outcome_year2015 <- dummies_outcome_year[,3]
aac_intakes_outcomes2$outcome_year2016 <- dummies_outcome_year[,4]
aac_intakes_outcomes2$outcome_year2017 <- dummies_outcome_year[,5]
aac_intakes_outcomes2$outcome_year2018 <- dummies_outcome_year[,6]

dummies_color <- dummy.data.frame(data.frame(aac_intakes_outcomes2$color_new))

#prüfe ob plausible Farben für übrige Tierrassen.  table(aac_intakes_outcomes2$color_new, aac_intakes_outcomes2$animal_type)
#Grün keine Werte mehr. Andere Farben alle plausibel

aac_intakes_outcomes2$colorApricot <- dummies_color[,1]
aac_intakes_outcomes2$colorBeige <- dummies_color[,2]
aac_intakes_outcomes2$colorBlack <- dummies_color[,3]
aac_intakes_outcomes2$colorBlue <- dummies_color[,4]
aac_intakes_outcomes2$colorBrown <- dummies_color[,5]
aac_intakes_outcomes2$colorGray <- dummies_color[,6]
aac_intakes_outcomes2$colorLilac <- dummies_color[,7]
aac_intakes_outcomes2$colorMulticolor <- dummies_color[,8]
aac_intakes_outcomes2$colorOrange <- dummies_color[,9]
aac_intakes_outcomes2$colorPink <- dummies_color[,10]
aac_intakes_outcomes2$colorRed <- dummies_color[,11]
aac_intakes_outcomes2$colorSilver <- dummies_color[,12]
aac_intakes_outcomes2$colorWhite <- dummies_color[,13]
aac_intakes_outcomes2$colorYellow <- dummies_color[,14]

aac_intakes_outcomes2$age_upon_intake_.days. <- as.numeric(aac_intakes_outcomes2$age_upon_intake_.days.)
aac_intakes_outcomes2$age_upon_outcome_.days. <- as.numeric(aac_intakes_outcomes2$age_upon_outcome_.days.)
aac_intakes_outcomes2$time_in_shelter_days <- as.numeric(aac_intakes_outcomes2$time_in_shelter_days)

dummies_suif<- dummy.data.frame(data.frame(aac_intakes_outcomes2$sex_upon_intake_first))
aac_intakes_outcomes2$sex_upon_intake_first_Intact <- dummies_suif[,1]
aac_intakes_outcomes2$sex_upon_intake_first_Sterilized <- dummies_suif[,2]
aac_intakes_outcomes2$sex_upon_intake_first_Unknown <- dummies_suif[,3]

dummies_suof<- dummy.data.frame(data.frame(aac_intakes_outcomes2$sex_upon_outcome_first))
aac_intakes_outcomes2$sex_upon_outcome_first_Intact <- dummies_suof[,1]
aac_intakes_outcomes2$sex_upon_outcome_first_Sterilized <- dummies_suof[,2]
aac_intakes_outcomes2$sex_upon_outcome_first_Unknown <- dummies_suof[,3]

aac_intakes_outcomes2$outcome_type_adopt <- as.factor(aac_intakes_outcomes2$outcome_type_adopt)
aac_intakes_outcomes2$breed <- as.factor(aac_intakes_outcomes2$breed)

#Entfernen aller 10 Originalspalten, die Dummycodiert wurden

aac_intakes_outcomes2[ ,c('intake_condition', 'intake_type', 'sex_upon_outcome_second', 'intake_month', 'intake_year', 'outcome_month', 'outcome_year', 'color_new', 'sex_upon_intake_first', 'sex_upon_outcome_first')] <- list(NULL)


```
</details>

# Finale Datensätze zur Modellierung
Als Basis für einen Gesamtdatensatz zur Modellierung werden die drei ausgewählten Tierarten dummycodiert.
```{r datasets new, message=FALSE, warning=FALSE}
allanimals <- aac_intakes_outcomes2
dummies_animals<- dummy.data.frame(data.frame(allanimals$animal_type))

allanimals$cat <- dummies_animals[,1]
allanimals$dog <- dummies_animals[,2]
allanimals$rabbit <- dummies_animals[,3]

allanimals<- allanimals[,-c(1)]

```


## Split Daten nach Tier 

Es werden außerdem Datasets pro Tierart erstellt. 
Da für jede Tierart ein eigenes Modell gefittet wird, wird die Tierartvariable innerhalb dieser Datensätze nicht benötigt und entfernt.
Für jedes Modell bzw. jede Tierart wird ein Trainingsdatensatz erstellt, anhand dessen das Modell trainiert werden soll und ein Testdatensatz, der nach dem Fitting des Modells dazu verwendet wird, um zu bewerten, wie gut das Modell generalisiert, d.h. wie gut die Vorhersage für "ungesehene" Daten beim Training funktioniert. Die Aufteilung erfolgt in einem Verhältnis von 70/30. Ziel ist es, ein Modell zu fitten, das komplex genug ist, um die Zusammenhänge des Phänomens abzubilden (deshalb wurde beispielsweise kein zu einfaches Modell, wie etwa k-nearest-neighbor verwendet, um Underfitting zu vermeiden), und andererseits nicht zu stark auf die Trainingsdaten fittet, um ein Overfitting ("Auswendiglernen") zu verhindern. Um die Performance des Modells zu bewerten, werden wir die Confusion Matrix berechnen, in der für jede Vorhersage (Adoption / keine Adoption) die Anteile an richtiger Vorhersage (=Accuracy) und falscher Vorhersage abgebildet werden. 

```{r dataset split, results='hide'}

rabbits <- subset(aac_intakes_outcomes2, animal_type == "Rabbit")
rabbits <- rabbits[,-c(1)]
rabbits$ breed <- as.factor(rabbits$breed)

dogs <- subset(aac_intakes_outcomes2, animal_type == "Dog")
dogs <- dogs[,-c(1)]
dogs$breed <- as.factor(dogs$breed)

cats <- subset(aac_intakes_outcomes2, animal_type == "Cat")
cats <- cats[,-c(1)]
cats$breed <- as.factor(cats$breed)

```

### Train Test Split - alle Tierarten
<details>
  <summary>Code Details</summary>
```{r}

train_function <- createDataPartition(
  y = allanimals$outcome_type_adopt,
  p = .70,
  list = FALSE
)

training <- allanimals[ train_function,]
testing  <- allanimals[-train_function,]
```
</details>

### Train/Test Split für Hunde

Jedes Subset wird wiederum in ein Test- und Trainingsset unterteilt. 
Beispiel Hunde:
```{r, results='hide'}
train_function <- createDataPartition(
  y = dogs$outcome_type_adopt,
  p = .70,
  list = FALSE
)

training_dog <- dogs[train_function,]
testing_dog  <- dogs[-train_function,]
```

### Train/Test Split für Katzen
<details>
  <summary>Code Details</summary>
```{r}
train_function <- createDataPartition(
  y = cats$outcome_type_adopt,
  p = .70,
  list = FALSE
)

training_cat <- cats[ train_function,]
testing_cat  <- cats[-train_function,]
```
</details>

### Train/Test Split für Hasen
<details>
  <summary>Code Details</summary>
```{r}
train_function <- createDataPartition(
  y = rabbits$outcome_type_adopt,
  p = .70,
  list = FALSE
)

training_rabbit <- rabbits[ train_function,]
testing_rabbit  <- rabbits[-train_function,]
```
</details>

***

# Aufstellen der Modelle
Zuerst werden Modelle mithilfe von Decision Trees aufgestellt, da diese gut interpretierbar sind. Danach wird untersucht, ob andere Methoden wie neuronale Netze ein ähnliches oder sogar besseres Ergebnis hinsichtlich Accuracy liefern.

## Decision Trees

Allgemeine Werte
```{r define CV and seed, results='hide'}
cv_5 = trainControl(method = "cv", number = 5)
seed_val = 123
```


Laden der gespeicherten Decision Tree Modelle
```{r load RData, results='hide'}
if (file.exists("decision_trees.RData") && !exists("tree_dog1") && !exists("tree_cat1") && !exists("tree_rabbit1"))
  load("decision_trees.RData")
```

Bei den Decision Trees werden alle Variablen im Datensatz und die Methode 'rpart' aus dem Caret Package verwendet, um eine Adoption vorherzusagen. 

Die Methode „rpart“ kann sowohl für Regressionsprobleme als auch Klassifikationsprobleme verwendet werden. „rpart“ steht in diesem Fall für Rekursive Partitionierung, was eine Methode der Multivariaten Analyse ist. Da bei der gewählten Fragestellung auch die Zusammenhänge und Abhängigkeiten zwischen den einzelnen Variablen in die Analyse einbezogen werden sollen, wurde eine multivariate Analysemethode bevorzugt. Bei „rpart“ ist der einzige Tuningparameter der Komplexitätsparameter, welcher die Größe des Baums bestimmt. Für die Modelle wurde entschieden, keinen Komplexitätsparameter anzugeben, um den optimalen Wert durch R bestimmen zu lassen. Für alle folgenden Modelle wird die beste Accuracy mit dem geringsten Komplexitätsparameter erreicht. Dies zeigt, dass hier durch ein komplexeres Modell ein besseres Resultat erzeugt wurde. Ein größerer Komplexitätsparameter bestraft neue Nodes mehr, weshalb hierdurch kleinere Bäume erzeugt werden, bei einem kleineren Komplexitätsparameter ist es umgekehrt. Es besteht jedoch die Gefahr des Overfittings.
Wir verwenden die „trainControl“-Methode zur Crossvalidierung beim Training. Cross Validation wurde ausgewählt, da das Ziel ist, eine bestmögliche Performance des Modells auf neue Daten zu erhalten. Indem bereits im Training das Modell auf unterschiedlichen Subsamples (bei cv 5 = 1/5 aller Trainingsdaten in jedem Fold) getestet wird, sollte das Modell besser generalisieren, als ohne CV. Um die Datenmenge des Validierungssets zu vergrößern, wurde die Anzahl an Folds auf 5 gesetzt. 

### Decision Tree für Hunde

Wie auch bei der Datensatzerstellung je Tierart werden im Folgenden pro Tierart Klassifikationsbäume mit 5-fold Cross-Validation gefittet.

```{r tree dogs, results='hide'}
set.seed(seed_val)

if (!exists("tree_dog1"))
  tree_dog1 <- train(
    outcome_type_adopt ~ .,
    data = training_dog,
    trControl = cv_5,
    method = "rpart")
```

Das gefittete Modell: 

```{r print tree dogs, echo=FALSE}
print(tree_dog1)
```

```{r confusion matrix dogs, echo=FALSE}
pred_tree_dog1 <- predict(tree_dog1, testing_dog)
conf_matrix_tree_dog1 <- confusionMatrix(pred_tree_dog1, testing_dog$outcome_type)
conf_matrix_tree_dog1
```

```{r model plot, echo=FALSE}
rpart.plot(tree_dog1$finalModel)
```

*Interpretation*

Der Tree zeigt, dass zuerst `time_in_shelter_days` eine Rolle spielt und somit die erste Abzweigung im Baum ist. Als weitere Variable verwendet der Baum `sex_upon_outcome_first_Sterilized` = 0.
Wenn der Hund weniger als 4 Tage im Tierheim ist, scheint eine Adoption auf Basis des Modells also als unwahrscheinlich (vermutlich handelt es sich dabei um entlaufene Tiere die bereits innerhalb der ersten 4 Tage wieder vom Besitzer abgeholt werden), wohingegen bei Hunden, die länger als 4 Tage im Tierheim verbleiben, die Wahrscheinlichkeit einer Adoption dann hoch ist, wenn der Hund sterilisiert ist. 

Die Specificity ist mit `r round(conf_matrix_tree_dog1$byClass["Specificity"]*100,0)`% um fast 20% höher als die Sensitivity, d.h. die Vorhersage von Hunden, die *nicht* adoptiert werden, ist genauer, als die für Hunde, die adoptiert werden. Gleichzeitig muss festgehalten werden, dass das Modell nur eine Accuracy von `r round(conf_matrix_tree_dog1$overall["Accuracy"]*100,0)`% hat, weshalb eine weitere Optimierung besonders sinnvoll erscheint. 

### Decision Tree für Katzen
<details>
  <summary>Code Details</summary>
```{r cats tree1}
set.seed(seed_val)
if (!exists("tree_cat1"))
  tree_cat1 <- train(
    outcome_type_adopt ~ .,
    data = training_cat,
    trControl = cv_5,
    method = "rpart")
```
</details>

Das gefittete Modell: 

```{r cats tree2,  echo=FALSE}
print(tree_cat1)
```

```{r confusion matrix cats,  echo=FALSE}
pred_tree_cat1 <- predict(tree_cat1, testing_cat)
conf_matrix_tree_cat1 <- confusionMatrix(pred_tree_cat1, testing_cat$outcome_type)
conf_matrix_tree_cat1
```

```{r plot model cats, echo=FALSE}
rpart.plot(tree_cat1$finalModel)
```

*Interpretation*

Bei Katzen ist `sex_upon_outcome_first_Sterilized` = 0 die erste Split Variable des Baumes, gefolgt von dem Alter der Katze bei Intake.
Daher scheinen für die Adoption einer Katze ähnliche Kriterien eine Rolle zu spielen, wie bei Hunden. Im Gegensatz zur Wahrscheinlichkeit einer Adoption eines Hundes spielt diesem Klassifikationsbaum zufolge das Alter der Katze eine wichtige Rolle: Wenn die Katze sterilisiert, und jünger als ein halbes Jahr ist, ist eine Adoption wahrscheinlicher. Ist die Katze älter als ein halbes Jahr, wird sie eher nicht adoptiert. Dies könnte daran liegen, dass Jungtiere bevorzugt adoptiert werden. 

Im Vergleich zum ersten Tree für die Vorhersage einer Adoption eines Hundes, zeigt sich beim Entscheidungsbaum für Katzen ohne Optimierung bereits eine bessere bzw. höhere Accuracy von `r round(conf_matrix_tree_cat1$overall["Accuracy"]*100,0)`%. Auffallend ist im direkten Vergleich der Modelle vor allem auch, dass bei Katzen (umgekehrt als bei Hunden), die Adoption besser vorhergesagt werden kann (Sensitivity = `r round(conf_matrix_tree_cat1$byClass["Sensitivity"]*100,0)`%), als Fälle, in denen Katzen nicht adoptiert werden (Specificity = `r round(conf_matrix_tree_cat1$byClass["Specificity"]*100,0)`%). 

### Decision Tree für Hasen
<details>
  <summary>Code Details</summary>
```{r model fitting rabbits}
set.seed(seed_val)

if (!exists("tree_rabbit1"))
  tree_rabbit1 <- train(
    outcome_type_adopt ~ .,
    data = training_rabbit,
    trControl = cv_5,
    method = "rpart")
```
</details>

Das gefittete Modell: 

```{r print model, echo=FALSE}
print(tree_rabbit1)
```

```{r confusion matrix rabbits, echo=FALSE}
pred_tree_rabbit1 <- predict(tree_rabbit1, testing_rabbit)
conf_matrix_tree_rabbit1 <- confusionMatrix(pred_tree_rabbit1, testing_rabbit$outcome_type)
conf_matrix_tree_rabbit1
```

```{r model plot2, echo=FALSE}
rpart.plot(tree_rabbit1$finalModel)
```

*Interpretation*

Bei Hasen gibt es 4 Splits: `sex_upon_outcome_first_Sterilized` = 0, `outcome_month9` = 0, `time_in_shelter_days` < 4.5, `age_upon_outcome_.days.` >= 405.
Daher erfolgt die erste Vorhersage einer Adoption eines Hasens auf Basis der Information, ob das Tier sterilisiert ist. Wie auch bei den anderen Tieren ist die Adoptionswahrscheinlichkeit dann deutlich höher, wenn das Tier bereits sterilisiert ist. Bei nicht sterilisierten Hasen, werden im Monat September jene, die länger als 4 Tage im Tierheim waren und jünger als 13 Monate sind eher adoptiert. 
Die Accuracy ist mit `r round(conf_matrix_tree_rabbit1$overall["Accuracy"]*100,0)`% noch besser als jene der anderen beiden Trees (Hunde und Katzen). 

<details>
  <summary>Code Details</summary>
```{r save decision trees}
if (!file.exists("decision_trees.RData"))
  save(tree_dog1, tree_cat1, tree_rabbit1, file = "decision_trees.RData")

```
</details>

## Variable Importance

Je Modell ist eine Tabelle der Wichtigkeit einer Variable sowie eine Grafik dargestellt. Die Tabelle enthält lediglich Variablen, bei denen die Importance größer 0 ist.

Die einfachen Klassifikationsbäume geben bereits einen guten ersten Einblick darin, welche Variablen für die Klassifikation bzw. Splitpunkte vorrangig herangezogen werden. 
Da sich zeigt, dass über die Tierarten hinweg die Hauptsplitpunkte auf ähnlichen Variablen basieren, soll mithilfe der Variable Importance ermittelt werden, ob noch weitere Zusatzinformationen aus den Modellen gewonnen werden können, die für das Tierheim für das bessere Verständnis von Adoptionsgründen genutzt werden kann. 
Dafür wird die Variable Importance aus den obig erstellten Bäumen (je Tier) erstellt und beschrieben.
Bei der Variable Importance wird berechnet, durch welchen Split der Gini-Index am stärksten verringert werden kann, d.h. welche Variable (bzw. der Split darauf) am besten hilft, die Vorhersage zu verbessern. 

### Variable Importance des Hundemodells

```{r}
imp_dog = vi(tree_dog1)
imp_dog = imp_dog[imp_dog$Importance>0,]
imp_dog_tab = tibble(Variable = imp_dog$Variable, Importance = imp_dog$Importance)
imp_dog_tab
vip(tree_dog1, width = 0.5, fill = "green3", num_features = 6)
```

Es ist ersichtlich, dass für den Decision Tree der Hunde 6 Prädiktoren eine Rolle spielen:

* `sex_upon_outcome_first_Sterilized`
* `sex_upon_outcome_first_Intact`
* `time_in_shelter_days`
* `intake_typePublic Assist`
* `age_upon_intake_.days.`
* `intake_typeStray`

Die wichtigsten Variablen sind neben der bereits im Decisiontree als Splitpunkt ermittelten `sex_upon_outcome_first_Sterilized` auch das `sex_upon_outcome_first_Intact.`

### Variable Importance des Katzenmodells

```{r, echo=FALSE}
imp_cat = vi(tree_cat1)
imp_cat = imp_cat[imp_cat$Importance>0,]
imp_cat_tab = tibble(Variable = imp_cat$Variable, Importance = imp_cat$Importance)
imp_cat_tab
vip(tree_cat1, width = 0.5, fill = "green3", num_features = 8)
```

Im Modell der Katzen finden sich ähnliche Prädiktoren wieder, hinzugekommen sind hier:

* `age_upon_outcome_.days.`
* `sex_upon_intake_first_Sterilized`
* `sex_upon_intake_first_Intact`
* `sexuponoutcomesecond_unknown`

Hier ist im Gegensatz zu den Hunden das Alter der Tiere und die `time_in_shelter` am wichtigsten.

### Variable Importance des Hasenmodells
```{r, echo=FALSE}
imp_rab= vi(tree_rabbit1)
imp_rab = imp_rab[imp_rab$Importance>0,]
imp_rab_tab = tibble(Variable = imp_rab$Variable, Importance = imp_rab$Importance)
imp_rab_tab
vip(tree_rabbit1, width = 0.5, fill = "green3", num_features = 13)
```

Hier ist wie im Modell der Hunde die Variable `sex_upon_outcome_first_Sterilized` am wichtigsten.
Neben den bekannten Prädiktoren sind u.a. noch die Prädiktoren

* `outcome_month9`
* `intake_year2016`
* `outcome_year2016`
* `intake_month9`
* `intake_year2015`

von Bedeutung.

Die Relevanz der Jahreszeiten lässt darauf schließen, dass die Adoptionen von Hasen sich über die Jahre hinweg unterscheiden. Was Grund für das Ausreißerjahr 2016 war, müsste anhand von Brancheninformationen ermittelt werden, es könnt z.B. sein, dass es vermehrte mediale Aufmerksamkeit (z.B. durch Kampagnen / Testimonials) oder eine Art "Haustiertrend-Boost" für Hasen in diesem Jahr gab. Sollten sich die besonderen Outcome Jahre und Monate auf ein außergewöhnliches Ereignis zurückführen lassen, muss nochmals bewertet werden, ob diese Daten im Modell berücksichtigt werden sollten.


## Tree Tuning (Bagging, Boosting, Random Forest)
Es wurde versucht, noch weitere Trees, getunt mit Bagging, Boosting bzw. Random Forest, aufzustellen. Aufgrund der Datenmenge und Rechenkapaziätsgrenzen konnten diese nicht ausgeführt werden und es ist hier nur ein Beispielcode bzw. ein gespeichertes Beispielmodel angeführt. In einem weiteren Schritt werden daher weitere Modelle mit Neuronalen Netzen berechnet.

### Auswahl Daten 
Bei der Auswahl der Daten wurde auch versucht, die nummerischen Variablen bzw. die Breed auszuschließen, dies hat allerdings auch zu keinem erfolgreich gefitteten Modell geführt.
```{r eval=FALSE}
data_train_model <- training_cat[,-c(1:5)]
data_test_model <- testing_cat[,-c(1:5)]
```

### Random Forrest mit OOB 
Um die bei den Decision Trees erreichten Accuracies zu verbessern, sollten Random Forests aufgestellt werden. Diese haben den Vorteil, dass sie noch recht nah an Decision Trees sind und dadurch noch vergleichsweise leicht interpretierbar sind. Im Gegensatz zu den Decision Trees wird diesesmal OOB und nicht CV5 verwendet. Das hat den Grund, dass der Datensatz sehr viele Variablen hat und OOB bei der Erstellung eines Random Forrest performanter ist.

Max. Zahl für das tuneGrid (für die Metry) wurde mit 9 gewählt, da üblicherweise das Optimum von m die Wurzel aus p, d.h. Wurzel aus 78=9 (gerundet) ist. Das bedeutet, dass jeder Tree nur 9 Variablen (die jeweils für jeden Split random ausgewählt werden) für die Auswahl eines jeden Splits zur Verfügung hat. 
```{r eval=FALSE}
trcOOB <- trainControl(method="oob")

randomforest_OOB <- train(
  outcome_type_adopt ~ .,
  data = data_train_model,
  method = "rf",
  tuneGrid = expand.grid(mtry=seq(1,10,1)),
  trControl = trcOOB
)
```

```{r eval=FALSE}
RF_OOB_predict = predict(randomforest_OOB, data_test_model)
conf_matrix_RF_OOB <- confusionMatrix(RF_OOB_predict, data_test_model$outcome_type)
```

### Modell für Katzen
Der Random Forest mit OOB konnte beispielhaft für ein reduziertes Subsample mit 1000 Cat-Datensätzen gespeichert werden, wird aber nicht weiter herangezogen aufgrund der oben beschriebenen Performanceprobleme.
```{r eval=FALSE}
load("randomforestOOB_cats_n=1000.Rdata")
```


## Neuronales Netzwerk

Die Bäume dienen als gut interpretierbare Modelle für ein besseres Verständnis der Adoptionsgründe. Nun soll noch getestet werden, ob ein Modell, das stärker auf Vorhersage als auf Interpretierbarkeit abzielt, helfen kann, die Modellaccuracy noch weiter zu steigern. 
Bei den neuronalen Netzen wird die Variable `breed` ausgeschlossen, da sie  bei den Bäumen als nicht relevant identifiziert wurde. Außerdem werden die numerischen Variablen `intake_number`, `age_upon_intake_.days.`, `age_upon_outcome_.days.` und `time_in_shelter_days` vorab min-max normalisiert, um die Geschwindigkeit der Berechnung zu erhöhen (für das Hundedatenset konnte ohne Normalisierung aus Computer Performance technischen Gründen gar keine Berechnung  durchgeführt werden). Die Normalisierung ermöglichte dann eine (schnellere) Berechnung.
Es werden für jede Tierart jeweils zwei neuronale Netze erstellt, einmal mit allen Variablen und einmal mit den Variablen, die im Decision Tree schon als wichtig festgestellt wurden. 
Als Hyperparameter werden jeweils 3 Hidden Layers und ein Threshold von 1 verwendet, da diese Werte die beste Accuracy beim Fitten der Modelle geliefert haben.

Es wird erwartet, dass das Modell, das alle Variablen inkludiert, eine höhere Accuracy erzielt als jenes, das nur eine Teilmenge der Variablen enthält (weil die Mustererkennung unter Berücksichtigung von mehr Variablen genauer sein müsste). Andererseits soll auch getestet werden, ob ausschließlich unter Verwendung der (auf Basis der Variable Importance) wichtigsten Prädiktoren ein gleich gutes Ergebnis erzielt werden kann, wie mit dem gefitteten einfachen Baummodell.

Das neuronale Netz wird für jede Tierart visualisiert. Dies hat den Hintergrund, dass in der Bevölkerung teilweise kein (tiefes) Verständnis über neuronale Netze vorliegt. Da viele Menschen visuell Dinge besser aufnehmen können, wurde entschieden, die neuronalen Netze zu visualisieren und mittels Erläuterungen dem Tierheimpersonal näherzubringen. Auf der linken Seite befinden sich dabei die wichtigsten Features, die Einfluss auf die Klassifikation nehmen. Auch unbekannte Einflussfaktoren (Bias), die nicht in den Daten enthalten sind, werden abgebildet (in blau). Da jeder Input und Bias eine unterschiedliche Gewichtung haben kann, werden diese Gewichte auf den Verbindungen dargestellt. Schlussendlich gibt es zwei Möglichkeiten für den Output.

<details>
  <summary>Code Details</summary>
```{r load model}
if (file.exists("neuronale_netze.RData"))
  load("neuronale_netze.RData")
```
</details>

Definition von allgemeinen Funktionen
```{r, output='hide'}
maxidx <- function(arr) {
    return(which(arr == max(arr)))
}

normalize <- function(x) {
  return ((x - min(x)) / (max(x) - min(x)))
}
```

### Neuronales Netz für Hunde

Wie auch bei den Decision Trees wird pro Tierrasse ein Modell mit denselben Parametern wie für die anderen Tierrassen gefittet. 

Modellfitting unter Verwendung aller Variablen (normalisiert) außer Breed: 
```{r NN dogs, output='hide'}
set.seed(seed_val)

#Normalisierung der numerischen Variablen (Spalten 2-5)
training_dog_norm = training_dog
training_dog_norm[c(2:5)] <- as.data.frame(lapply(training_dog_norm[c(2:5)], normalize))

testing_dog_norm = testing_dog
testing_dog_norm[c(2:5)] <- as.data.frame(lapply(testing_dog_norm[c(2:5)], normalize))


#'Fullmodel' Fitting
if (!exists("net_model_dog"))
  net_model_dog <- neuralnet(outcome_type_adopt ~ .,
                  data=training_dog_norm[c(2:78)], 
                  hidden=c(3),
                  stepmax = 1000000,
                  threshold = 1, 
                  linear.output=T,
                  act.fct = "logistic")
```

Modellfitting mit einer Teilmenge/ Auswahl von Variablen (Auswahl auf Basis der Feature Importance): 
```{r NN dogs selected Vars, output='hide'}

set.seed(seed_val)

if (!exists("net_model_dog_selected"))
  net_model_dog_selected <- neuralnet(outcome_type_adopt ~ time_in_shelter_days+sex_upon_outcome_first_Sterilized,
                  data=training_dog_norm[c(2:78)], 
                  hidden=c(3),
                  stepmax = 1000000,
                  threshold = 1, 
                  linear.output=T,
                  act.fct = "logistic")
```

Visualisierung des neuronalen Netzes mit den wichtigen Features aus dem Decision Tree
```{r plot NN selected, echo=FALSE}
plot(net_model_dog_selected , rep="best")
```

Vergleich der Accuracy der Modelle
```{r model accuracy1 }
#Vorhersage für Modell mit allen Variablen 
pred_net_dog <- predict(net_model_dog,testing_dog_norm[c(2:78)])
idx <- apply(pred_net_dog, c(1), maxidx)
pred_net_dog <-as.factor(c('0', '1')[idx])

#Vorhersage für Modell mit Teilmenge von Variablen 
pred_net_dog_selected <- predict(net_model_dog_selected,testing_dog_norm[c(2:78)])
idx <- apply(pred_net_dog_selected, c(1), maxidx)
pred_net_dog_selected <-as.factor(c('0', '1')[idx])

#Confusion Matrizen für beide Modelle 
cf_net_dog <- confusionMatrix(pred_net_dog,testing_dog_norm$outcome_type_adopt)
cf_net_dog_selected <- confusionMatrix(pred_net_dog_selected,testing_dog_norm$outcome_type_adopt)

cat("All Variables: Accuracy", cf_net_dog$overall["Accuracy"], "\n")
cat("Selected Variables: Accuracy", cf_net_dog_selected$overall["Accuracy"], "\n")
```

*Interpretation*

Die Accuracy des NNs für Hunde ist unter Berücksichtigung aller Variablen deutlich besser als unter Verwendung eines Subsets und übertrifft in der Accuracy auch den Decision Tree. 


### Neuronales Netz für Katzen
<details>
  <summary>Code Details</summary>
```{r model fitting cats}

set.seed(seed_val)

training_cat_norm = training_cat
training_cat_norm[c(2:5)] <- as.data.frame(lapply(training_cat_norm[c(2:5)], normalize))

testing_cat_norm = testing_cat
testing_cat_norm[c(2:5)] <- as.data.frame(lapply(testing_cat_norm[c(2:5)], normalize))


if (!exists("net_model_cat"))
  net_model_cat <- neuralnet(outcome_type_adopt ~ .,
                  data=training_cat_norm[c(2:78)], 
                  hidden=c(3),
                  stepmax = 1000000,
                  threshold = 1, 
                  act.fct = "logistic")
```
</details>

<details>
  <summary>Code Details</summary>
```{r model fitting selected vars1}
set.seed(seed_val)

if (!exists("net_model_cat_selected"))
  net_model_cat_selected <- neuralnet(outcome_type_adopt ~ sex_upon_outcome_first_Sterilized+age_upon_intake_.days.,
                  data=training_cat_norm[c(2:78)], 
                  hidden=c(3),
                  stepmax = 1000000,
                  threshold = 1, 
                  act.fct = "logistic")
```
</details>

Visualisierung des neuronalen Netzes mit den wichtigen Features aus dem Decision Tree
```{r plot cats model, echo=FALSE}
plot(net_model_cat_selected , rep="best")
```

Vergleich der Accuracy der Modelle
```{r, echo=FALSE}
pred_net_cat <- predict(net_model_cat,testing_cat_norm[c(2:78)] )
idx <- apply(pred_net_cat, c(1), maxidx)
pred_net_cat <-as.factor(c('0', '1')[idx])

cf_net_cat <- confusionMatrix(pred_net_cat,testing_cat_norm$outcome_type_adopt)

pred_net_cat_selected <- predict(net_model_cat_selected,testing_cat_norm[c(2:78)] )
idx <- apply(pred_net_cat_selected, c(1), maxidx)
pred_net_cat_selected <-as.factor(c('0', '1')[idx])

cf_net_cat_selected  <- confusionMatrix(pred_net_cat_selected,testing_cat_norm$outcome_type_adopt)

cat("All Variables: Accuracy", cf_net_cat$overall["Accuracy"], "\n")
cat("Selected Variables: Accuracy", cf_net_cat_selected$overall["Accuracy"], "\n")
```

*Interpretation*

Die Accuracy des NNs für Katzen ist unter Berücksichtigung aller Variablen deutlich besser als unter Verwendung eines Subsets. Die Accuracy des Treemodels kann mit dem Neuronalen Netz um etwa `r round(cf_net_cat$overall["Accuracy"]*100,0)-round(conf_matrix_tree_cat1$overall["Accuracy"]*100,0)`% verbessert werden. 

### Neuronales Netz für Hasen

<details>
  <summary>Code Details</summary>
```{r modell fitting rabbits all vars}
set.seed(seed_val)
training_rabbit_norm = training_rabbit
training_rabbit_norm[c(2:5)] <- as.data.frame(lapply(training_rabbit_norm[c(2:5)], normalize))

testing_rabbit_norm = testing_rabbit
testing_rabbit_norm[c(2:5)] <- as.data.frame(lapply(testing_rabbit_norm[c(2:5)], normalize))


if (!exists("net_model_rabbit"))
  net_model_rabbit <- neuralnet(outcome_type_adopt ~ .,
                  data=training_rabbit[c(2:78)], 
                  hidden=c(3),
                  stepmax = 1000000,
                  threshold = 1, 
                  act.fct = "logistic")
```
</details>

<details>
  <summary>Code Details</summary>
```{r model fitting selected vars2}
set.seed(seed_val)
if (!exists("net_model_rabbit_selected"))
  net_model_rabbit_selected <- neuralnet(outcome_type_adopt ~ sex_upon_outcome_first_Sterilized+outcome_month9+time_in_shelter_days+age_upon_outcome_.days.,
                  data=training_rabbit[c(2:78)], 
                  hidden=c(3),
                  stepmax = 1000000,
                  threshold = 1, 
                  act.fct = "logistic")
```
</details>

Visualisierung des neuronalen Netzes mit den wichtigen Features aus dem Decision Tree
```{r model plot3, echo=FALSE}
plot(net_model_rabbit_selected , rep="best")
```

Vergleich der Accuracy der Modelle
```{r compare models, echo=FALSE}
pred_net_rabbit <- predict(net_model_rabbit,testing_rabbit_norm[c(2:78)])
idx <- apply(pred_net_rabbit, c(1), maxidx)
pred_net_rabbit <-as.factor(c('0', '1')[idx])

pred_net_rabbit_selected <- predict(net_model_rabbit_selected,testing_rabbit_norm[c(2:78)])
idx <- apply(pred_net_rabbit_selected, c(1), maxidx)
pred_net_rabbit_selected <-as.factor(c('0', '1')[idx])

cf_net_rabbit <- confusionMatrix(pred_net_rabbit,testing_rabbit_norm$outcome_type_adopt)
cf_net_rabbit_selected <- confusionMatrix(pred_net_rabbit_selected,testing_rabbit_norm$outcome_type_adopt)
cat("All Variables: Accuracy", cf_net_rabbit$overall["Accuracy"], "\n")
cat("Selected Variables: Accuracy", cf_net_rabbit_selected$overall["Accuracy"], "\n")
```

*Interpretation*

Die Accuracy des NNs für Hasen ist unter Berücksichtigung aller Variablen deutlich besser als unter Verwendung eines Subsets. Die Accuracy des Treemodels kann, wie auch bei den Katzen, mit dem Neuronalen Netz nicht verbessert werden. 

####Variable Importance im NN

Da die in den Bäumen ermittelten Variablen mit hoher Wichtigkeit für das Hasen Modell stark von jenen für Hunde und Katzen abweichen, wurde noch ein weiteres Neuronales Net (andere Library, die auch Einsicht der Variablen Importance des NNs ermöglicht) gefittet, um zu prüfen, inwiefern die Relevanz der Variablen im Neuronalen Netz von jenen abweicht, die im Tree ermittelt wurden.

<details>
  <summary>Code Details</summary>
```{r nnet, results='hide'}
set.seed(123)
control <- trainControl(method = 'cv', number = 10)

nnet_model_rabbit <- train(outcome_type_adopt ~., data = training_rabbit_norm[2:78], method = 'nnet', trControl = control, tuneGrid=expand.grid(size=c(10), decay=c(0.1)), maxi = 100000 )

pred_nnet_rabbit <- predict(nnet_model_rabbit,testing_rabbit_norm[c(2:5,7:78)])
cf_nnet_rabbit <- confusionMatrix(pred_nnet_rabbit,testing_rabbit_norm$outcome_type_adopt)
cat("All Variables: Accuracy", cf_nnet_rabbit$overall["Accuracy"], "\n")
```
</details>

```{r}
imp_nn_s_rab = vi(nnet_model_rabbit)
imp_nn_s_rab = imp_nn_s_rab[imp_nn_s_rab$Importance>5,]
imp_nn_s_rab_tab = tibble(Variable = imp_nn_s_rab$Variable, Importance = imp_nn_s_rab$Importance)

vip(nnet_model_rabbit, width = 0.5, fill = "green3")
```


Neben der Sterilisation, die  im Tree eine der wichtigsten Variable darstellt, spielten beim Neuronalen Netz vorrangig Monate und Jahre, in denen der Hase ins Tierheim gekommen ist bzw. das Tierheim verlassen hat, eine Rolle. Diese weichen leicht von den wichtigen Variablen im Tree ab. Die Darstellung bestätigt aber jedenfalls nochmals, dass bei Hasen tatsächlich Saisoninformationen hilfreich dafür sind, die Adoption vorherzusagen.

### Vergleich aller Neuronalen Netzwerke 

```{r results='hide', echo=FALSE}
table_nums(name = "accuracies_nn_table", caption = "Accuracies der Neuronalen Netze")
```
<div class = "row">
<div class = "col-md-6">
```{r accuracies_nn_table, echo=FALSE}
accuracyTable = tibble(Tierart="Hunde", Accuracy_All=cf_net_dog$overall["Accuracy"], Accuracy_Selected_Features=cf_net_dog_selected$overall["Accuracy"])
accuracyTable = add_row(accuracyTable, Tierart="Katzen", Accuracy_All=cf_net_cat$overall["Accuracy"], Accuracy_Selected_Features=cf_net_cat_selected$overall["Accuracy"])
accuracyTable = add_row(accuracyTable, Tierart="Hasen", Accuracy_All=cf_net_rabbit$overall["Accuracy"], Accuracy_Selected_Features=cf_net_rabbit_selected$overall["Accuracy"])

kable(accuracyTable, align = "l") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE, position="right") %>%
  footnote(general = "", general_title = table_nums("accuracies_nn_table"))
```
</div>

<div class = "col-md-6">
```{r  echo=FALSE}
accuracy_net_barplot <- read.table(header=TRUE, text=paste("Animal Input_Data Accuracy",
"\nHund All_Features", cf_net_dog$overall["Accuracy"],
"\nKatze All_Features", cf_net_cat$overall["Accuracy"],
"\nHase All_Features", cf_net_rabbit$overall["Accuracy"],
"\nHund Selected_Features",  cf_net_dog_selected$overall["Accuracy"],
"\nKatze Selected_Features", cf_net_cat_selected$overall["Accuracy"],
"\nHase Selected_Features",  cf_net_rabbit_selected$overall["Accuracy"],  sep=" "))
accuracy_net_barplot$Animal= factor(accuracy_net_barplot$Animal,levels(accuracy_net_barplot$Animal)[c(2,3,1)])
ggplot(accuracy_net_barplot, aes(Animal, y=Accuracy, fill = Input_Data)) + 
  geom_bar(stat="identity", position = "dodge") + 
  scale_fill_brewer(palette = "Set1")
```
</div>
</div>

`r table_nums("accuracies_nn_table", display = "cite")` zeigt, dass bei allen Netzen die Accuracy unter Verwendung aller Features höher ist, als unter Verwendung eines Subsets, obwohl bei den Modellen für Hasen kein Unterschied zu erkennen ist. Somit konnte unsere Annahme der besseren Accuracy bei Netzen mit allen Variablen bestätigt werden.
Wie auch bei den Bäumen ist die Accuracy für Hunde weiterhin am geringsten, konnte jedoch deutlich von `r round(conf_matrix_tree_dog1$overall["Accuracy"]*100,0)`% auf `r round(cf_net_dog$overall["Accuracy"]*100,0)`% mit dem NN verbessert werden. 

<details>
  <summary>Code Details</summary>
```{r save NN models}
if (!file.exists("neuronale_netze.RData"))
  save(net_model_dog, net_model_dog_selected, net_model_cat, net_model_cat_selected, net_model_rabbit,net_model_rabbit_selected, file = "neuronale_netze.RData")
```
</details>

```{r echo=FALSE, results='hide'}
table_nums(name = "compare_accuracies", caption = "Test-Accuracies der Modelle")
```

#Conclusion

Das Vorgehen bei der Prädiktion hat zufriedenstellende Ergebnisse geliefert. Es konnten einerseits relevante Faktoren für die Adoption der am häufigsten im Tierheim vorhandenen Tierarten eruiert werden, andererseits konnten Neuronale Netze mit guter Accuracy (über 80%, siehe `r table_nums("compare_accuracies", display = "cite")`) gefittet werden.

<div class = "row">
<div class = "col-md-6">
```{r compare_accuracies, echo=FALSE}
accuracy_compare_table = tibble(Modell="Decision Tree", Hunde=conf_matrix_tree_dog1$overall["Accuracy"], Katzen=conf_matrix_tree_cat1$overall["Accuracy"], Hasen=conf_matrix_tree_rabbit1$overall["Accuracy"])

accuracy_compare_table = add_row(accuracy_compare_table, Modell="Neuronales Netz", Hunde=cf_net_dog$overall["Accuracy"], Katzen=cf_net_cat$overall["Accuracy"], Hasen=cf_net_rabbit$overall["Accuracy"])

kable(accuracy_compare_table, align = "l") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE, position="right") %>%
  footnote(general = "", general_title = table_nums("compare_accuracies"))
```
</div>

<div class = "col-md-6">
```{r echo=FALSE}
accuracy_compare_barplot <- read.table(header=TRUE, text= paste("Animal Model Accuracy",
"\nHund Decision_Tree", conf_matrix_tree_dog1$overall["Accuracy"],
"\nKatze Decision_Tree", conf_matrix_tree_cat1$overall["Accuracy"],
"\nHase Decision_Tree", conf_matrix_tree_rabbit1$overall["Accuracy"],
"\nHund Neuronales_Netz",  cf_net_dog$overall["Accuracy"],
"\nKatze Neuronales_Netz", cf_net_cat$overall["Accuracy"],
"\nHase Neuronales_Netz",  cf_net_rabbit$overall["Accuracy"],  sep=" "))
accuracy_compare_barplot$Animal= factor(accuracy_compare_barplot$Animal,levels(accuracy_compare_barplot$Animal)[c(2,3,1)])
ggplot(accuracy_compare_barplot, aes(Animal, y=Accuracy, fill = Model)) + 
  geom_bar(stat="identity", position = "dodge") + 
  scale_fill_brewer(palette = "Dark2")
``````
</div>
</div>

Die anfangs formulierte Hypothese, dass die Adoption vor allem vom Alter und Gesundheitszustand abhängig ist, konnte nur teilweise verifiziert werden. Außerdem stellte sich heraus, dass für unterschiedliche Tierarten unterschiedliche Faktoren und in unterschiedlichem Ausmaß einen Einfluss auf die Adoptionswahrscheinlichkeit nehmen. 

Bei Hunden sind die Sterilisation, die Zeitdauer im Tierheim, das Alter und ob es sich um einen Streuner handelt die wichtigsten Kriterien. Für das Tierheim bedeutet das, dass durch eine Sterilization die Adoption wahrscheinlich am stärksten beeinflusst werden kann. 
Bei Katzen ist das Alter für die Adoption relevanter als bei Hunden, aber auch bei dieser Tierart spielt die Sterilisation eine bedeutende Rolle. 

Überraschend ist, dass der Gesundheitszustand in keinem der Modelle als relevant für eine Adoption bewertet wurde. 
Bei den Vorhersagen der Adoption von Hasen zeigte sich ein extremer Unterschied der relevanten Faktoren im Vergleich zu den Hunden und Katzen. Es scheint, als gäbe es eine "saisonale" Abhängigkeit für die Adoption, wir vermuten, dass z.B. um Feiertage (Ostern, Weihnachten), die Adoptionszahl für Hasen ansteigt. Das Tierheim könnte diese Information z.B. dazu nutzen, um die Auslastung/Belegung im Tierheim zu optimieren, da entweder in Zeiten, wo weniger Adoptionen eintreten, die Plätze kurzzeitig ausgebaut werden, da absehbar ist, wann diese wieder reduziert werden können. 

Das Tierheim könnte mit diesen Modellen besser einschätzen, ob und unter welchen Bedingungen gewisse Hunde, Katzen und Hasen eher adoptiert werden. Außerdem können für jene, die eher nicht adoptiert werden, gegebenfalls zusätzliche Maßnahmen (Sterilisation, Marketing, ...) getroffen werden, um auch ihre Chance auf eine Adoption zu erhöhen.


#Diskussion
Zur Verbesserung der Ergebnisse hätte der `outcome_subtype` miteinbezogen werden können. Hierdurch hätten die verwendeten Outcome-Types genauer aufgeteilt werden können und ggfs. eine bessere Prediction erreicht werden können. Da jedoch die Fachkenntnis in diesem Bereich teilweise zu wenig vorhanden war, wurde diese Variable nicht berücksichtigt. Ferner ist zu beachten, dass je weiter man die Variable aufgeteilt hätte, desto kleiner wäre der Datensatz je Outcome gewesen, was wiederrum das Training erschwert hätte.
Durch die Einschränkung des Outcome-Types auf lediglich adoptiert ja/nein kann ebenfalls die Modellqualität gelitten haben, da möglicherweise nicht alle anderen Outcome-Types bedenkenlos in eine Kategorie gesteckt werden dürfen. Hier sind als Beispiel die Ausprägungen Return to Owner, Rto-Adopt und Transfer zu nennen, die insgesamt - im Vergleich zu bspw. Died und Euthansaia - eher positiv annotiert sind und deshalb möglicherweise andere Einflussfaktoren haben, die vom Modell schwerer zu erlernen und von Adoption zu trennen sind.

Eine weitere Variable die noch genauer betrachtet hätte werden können, ist `breed`. Diese wurden in den Decision Trees als nicht relevant identifziert und darum in den Neuronalen Netzen nicht mehr verwendet. Jedoch könnte die Relevanz des Features durch Zusammenfügen mehrere Rassen zu einer Kategorie weitere Erkenntnisse liefern. Zum Beispiel ob Rassekatzen eher adoptiert werden als nicht Rassekatzen. Um diese einzelnen Kategorien der Rassen zu definieren, wäre jedoch noch eine tiefergehende Recherche im Bereich der Tierassen nötig bzw. wäre es am besten, einen Experte auf diesem Gebiet miteinzubeziehen. 


Die Aufgabe hätte auch anders angegangen werden können. In der Originalquelle waren auch Datensätze für lediglich Intakes enthalten. Hiermit hätte eine Prediction durchgeführt werden können, die den Outcome ja/nein vorhersagt. Unsere Fragestellung richtete sich jedoch bewusst auf die Adoption sowie die anderen Outcome-Types.  



![](snoopy.png)
